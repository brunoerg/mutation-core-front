[
  {
    "filename": "feature_assumeutxo.py",
    "diffs": [
      "diff --git a/test/functional/feature_assumeutxo.py b/muts/feature_assumeutxo.mutant.88.py\nold mode 100755\nnew mode 100644\nindex 2995ece42f..2404bb37cb\n--- a/test/functional/feature_assumeutxo.py\n+++ b/muts/feature_assumeutxo.mutant.88.py\n@@ -687,7 +687,7 @@ class AssumeutxoTest(BitcoinTestFramework):\n \n         # Upon restart, the node must stay in 'limited' mode until the background\n         # chain sync completes.\n-        self.restart_node(2, extra_args=self.extra_args[2])\n+        \n         self.assert_only_network_limited_service(n2)\n \n         self.connect_nodes(0, 2)\n",
      "diff --git a/test/functional/feature_assumeutxo.py b/muts/feature_assumeutxo.mutant.87.py\nold mode 100755\nnew mode 100644\nindex 2995ece42f..e6acbd849c\n--- a/test/functional/feature_assumeutxo.py\n+++ b/muts/feature_assumeutxo.mutant.87.py\n@@ -673,7 +673,7 @@ class AssumeutxoTest(BitcoinTestFramework):\n             assert_equal(loaded['coins_loaded'], SNAPSHOT_BASE_HEIGHT)\n             assert_equal(loaded['base_height'], SNAPSHOT_BASE_HEIGHT)\n \n-        normal, snapshot = n2.getchainstates()['chainstates']\n+        \n         assert_equal(normal['blocks'], START_HEIGHT)\n         assert_equal(normal.get('snapshot_blockhash'), None)\n         assert_equal(normal['validated'], True)\n",
      "diff --git a/test/functional/feature_assumeutxo.py b/muts/feature_assumeutxo.mutant.74.py\nold mode 100755\nnew mode 100644\nindex 2995ece42f..5585ff70fa\n--- a/test/functional/feature_assumeutxo.py\n+++ b/muts/feature_assumeutxo.mutant.74.py\n@@ -551,7 +551,7 @@ class AssumeutxoTest(BitcoinTestFramework):\n         # point, it winds up in m_blocks_unlinked and triggers a corner case\n         # that previously crashed CheckBlockIndex.\n         n1.submitblock(stale_block)\n-        n1.getchaintips()\n+        \n         n1.getblock(stale_hash)\n \n         self.log.info(\"Submit a spending transaction for a snapshot chainstate coin to the mempool\")\n",
      "diff --git a/test/functional/feature_assumeutxo.py b/muts/feature_assumeutxo.mutant.93.py\nold mode 100755\nnew mode 100644\nindex 2995ece42f..edafcadcf8\n--- a/test/functional/feature_assumeutxo.py\n+++ b/muts/feature_assumeutxo.mutant.93.py\n@@ -714,7 +714,7 @@ class AssumeutxoTest(BitcoinTestFramework):\n \n             assert_equal(n.getblockchaininfo()[\"blocks\"], FINAL_HEIGHT)\n \n-            chainstate, = n.getchainstates()['chainstates']\n+            \n             assert_equal(chainstate['blocks'], FINAL_HEIGHT)\n \n             if i != 0:\n",
      "diff --git a/test/functional/feature_assumeutxo.py b/muts/feature_assumeutxo.mutant.54.py\nold mode 100755\nnew mode 100644\nindex 2995ece42f..e800c194e3\n--- a/test/functional/feature_assumeutxo.py\n+++ b/muts/feature_assumeutxo.mutant.54.py\n@@ -319,7 +319,7 @@ class AssumeutxoTest(BitcoinTestFramework):\n         # Now that the snapshot_node is synced, verify the ibd_node can sync from it\n         self.connect_nodes(snapshot_node.index, ibd_node.index)\n         assert 'NETWORK' in ibd_node.getpeerinfo()[0]['servicesnames']\n-        self.sync_blocks(nodes=(ibd_node, snapshot_node))\n+        \n \n     def assert_only_network_limited_service(self, node):\n         node_services = node.getnetworkinfo()['localservicesnames']\n",
      "diff --git a/test/functional/feature_assumeutxo.py b/muts/feature_assumeutxo.mutant.15.py\nold mode 100755\nnew mode 100644\nindex 2995ece42f..d4a829f863\n--- a/test/functional/feature_assumeutxo.py\n+++ b/muts/feature_assumeutxo.mutant.15.py\n@@ -127,7 +127,7 @@ class AssumeutxoTest(BitcoinTestFramework):\n         cases = [\n             # (content, offset, wrong_hash, custom_message)\n             [b\"\\xff\" * 32, 0, \"7d52155c9a9fdc4525b637ef6170568e5dad6fabd0b1fdbb9432010b8453095b\", None],  # wrong outpoint hash\n-            [(2).to_bytes(1, \"little\"), 32, None, \"Bad snapshot data after deserializing 1 coins.\"],  # wrong txid coins count\n+            \n             [b\"\\xfd\\xff\\xff\", 32, None, \"Mismatch in coins count in snapshot metadata and actual snapshot data\"],  # txid coins count exceeds coins left\n             [b\"\\x01\", 33, \"9f4d897031ab8547665b4153317ae2fdbf0130c7840b66427ebc48b881cb80ad\", None],  # wrong outpoint index\n             [b\"\\x81\", 34, \"3da966ba9826fb6d2604260e01607b55ba44e1a5de298606b08704bc62570ea8\", None],  # wrong coin code VARINT\n",
      "diff --git a/test/functional/feature_assumeutxo.py b/muts/feature_assumeutxo.mutant.82.py\nold mode 100755\nnew mode 100644\nindex 2995ece42f..f687d31b92\n--- a/test/functional/feature_assumeutxo.py\n+++ b/muts/feature_assumeutxo.mutant.82.py\n@@ -633,7 +633,7 @@ class AssumeutxoTest(BitcoinTestFramework):\n         for i in (0, 1):\n             n = self.nodes[i]\n             self.log.info(f\"Restarting node {i} to ensure (Check|Load)BlockIndex passes\")\n-            self.restart_node(i, extra_args=self.extra_args[i])\n+            \n \n             assert_equal(n.getblockchaininfo()[\"blocks\"], FINAL_HEIGHT)\n \n",
      "diff --git a/test/functional/feature_assumeutxo.py b/muts/feature_assumeutxo.mutant.33.py\nold mode 100755\nnew mode 100644\nindex 2995ece42f..0921a89c78\n--- a/test/functional/feature_assumeutxo.py\n+++ b/muts/feature_assumeutxo.mutant.33.py\n@@ -244,7 +244,7 @@ class AssumeutxoTest(BitcoinTestFramework):\n         parent_block_hash = node0.getblockhash(SNAPSHOT_BASE_HEIGHT - 1)\n         block_time = node0.getblock(node0.getbestblockhash())['time'] + 1\n         fork_block1 = create_block(int(parent_block_hash, 16), create_coinbase(SNAPSHOT_BASE_HEIGHT), block_time)\n-        fork_block1.solve()\n+        \n         fork_block2 = create_block(fork_block1.sha256, create_coinbase(SNAPSHOT_BASE_HEIGHT + 1), block_time + 1)\n         fork_block2.solve()\n         node1.submitheader(fork_block1.serialize().hex())\n",
      "diff --git a/test/functional/feature_assumeutxo.py b/muts/feature_assumeutxo.mutant.52.py\nold mode 100755\nnew mode 100644\nindex 2995ece42f..fefc760a60\n--- a/test/functional/feature_assumeutxo.py\n+++ b/muts/feature_assumeutxo.mutant.52.py\n@@ -311,7 +311,7 @@ class AssumeutxoTest(BitcoinTestFramework):\n         # Now disconnect nodes and finish background chain sync\n         self.disconnect_nodes(ibd_node.index, snapshot_node.index)\n         self.connect_nodes(snapshot_node.index, miner.index)\n-        self.sync_blocks(nodes=(miner, snapshot_node))\n+        \n         # Check the base snapshot block was stored and ensure node signals full-node service support\n         self.wait_until(lambda: not try_rpc(-1, \"Block not available (not fully downloaded)\", snapshot_node.getblock, snapshot_block_hash))\n         self.wait_until(lambda: 'NETWORK' in snapshot_node.getnetworkinfo()['localservicesnames'])\n",
      "diff --git a/test/functional/feature_assumeutxo.py b/muts/feature_assumeutxo.mutant.95.py\nold mode 100755\nnew mode 100644\nindex 2995ece42f..56940ff20d\n--- a/test/functional/feature_assumeutxo.py\n+++ b/muts/feature_assumeutxo.mutant.95.py\n@@ -729,7 +729,7 @@ class AssumeutxoTest(BitcoinTestFramework):\n \n         self.log.info(\"Test -reindex of an assumeutxo-synced node\")\n         self.restart_node(2, extra_args=['-reindex=1', *self.extra_args[2]])\n-        self.connect_nodes(0, 2)\n+        \n         self.wait_until(lambda: n2.getblockcount() == FINAL_HEIGHT)\n \n         self.test_snapshot_in_a_divergent_chain(dump_output['path'])\n",
      "diff --git a/test/functional/feature_assumeutxo.py b/muts/feature_assumeutxo.mutant.94.py\nold mode 100755\nnew mode 100644\nindex 2995ece42f..14e469cf11\n--- a/test/functional/feature_assumeutxo.py\n+++ b/muts/feature_assumeutxo.mutant.94.py\n@@ -728,7 +728,7 @@ class AssumeutxoTest(BitcoinTestFramework):\n         self.wait_until(lambda: n2.getblockcount() == FINAL_HEIGHT)\n \n         self.log.info(\"Test -reindex of an assumeutxo-synced node\")\n-        self.restart_node(2, extra_args=['-reindex=1', *self.extra_args[2]])\n+        \n         self.connect_nodes(0, 2)\n         self.wait_until(lambda: n2.getblockcount() == FINAL_HEIGHT)\n \n",
      "diff --git a/test/functional/feature_assumeutxo.py b/muts/feature_assumeutxo.mutant.90.py\nold mode 100755\nnew mode 100644\nindex 2995ece42f..cfd7b495c1\n--- a/test/functional/feature_assumeutxo.py\n+++ b/muts/feature_assumeutxo.mutant.90.py\n@@ -692,7 +692,7 @@ class AssumeutxoTest(BitcoinTestFramework):\n \n         self.connect_nodes(0, 2)\n         self.wait_until(lambda: n2.getchainstates()['chainstates'][-1]['blocks'] == FINAL_HEIGHT)\n-        self.sync_blocks(nodes=(n0, n2))\n+        \n \n         self.log.info(\"Ensuring background validation completes\")\n         self.wait_until(lambda: len(n2.getchainstates()['chainstates']) == 1)\n",
      "diff --git a/test/functional/feature_assumeutxo.py b/muts/feature_assumeutxo.mutant.63.py\nold mode 100755\nnew mode 100644\nindex 2995ece42f..957236fd5f\n--- a/test/functional/feature_assumeutxo.py\n+++ b/muts/feature_assumeutxo.mutant.63.py\n@@ -363,7 +363,7 @@ class AssumeutxoTest(BitcoinTestFramework):\n                 temp_invalid = n0.getbestblockhash()\n                 n0.invalidateblock(temp_invalid)\n                 stale_hash = self.generateblock(n0, output=\"raw(aaaa)\", transactions=[], sync_fun=self.no_op)[\"hash\"]\n-                n0.invalidateblock(stale_hash)\n+                \n                 n0.reconsiderblock(temp_invalid)\n                 stale_block = n0.getblock(stale_hash, 0)\n \n",
      "diff --git a/test/functional/feature_assumeutxo.py b/muts/feature_assumeutxo.mutant.32.py\nold mode 100755\nnew mode 100644\nindex 2995ece42f..7ec72630ff\n--- a/test/functional/feature_assumeutxo.py\n+++ b/muts/feature_assumeutxo.mutant.32.py\n@@ -231,7 +231,7 @@ class AssumeutxoTest(BitcoinTestFramework):\n \n         # Now lets sync the nodes and wait for the background validation to finish\n         self.connect_nodes(0, 3)\n-        self.sync_blocks(nodes=(n0, n3))\n+        \n         self.wait_until(lambda: len(n3.getchainstates()['chainstates']) == 1)\n \n     def test_snapshot_not_on_most_work_chain(self, dump_output_path):\n",
      "diff --git a/test/functional/feature_assumeutxo.py b/muts/feature_assumeutxo.mutant.80.py\nold mode 100755\nnew mode 100644\nindex 2995ece42f..28a97ec181\n--- a/test/functional/feature_assumeutxo.py\n+++ b/muts/feature_assumeutxo.mutant.80.py\n@@ -611,7 +611,7 @@ class AssumeutxoTest(BitcoinTestFramework):\n \n         self.log.info(f\"Ensuring snapshot chain syncs to tip. ({FINAL_HEIGHT})\")\n         self.wait_until(lambda: n1.getchainstates()['chainstates'][-1]['blocks'] == FINAL_HEIGHT)\n-        self.sync_blocks(nodes=(n0, n1))\n+        \n \n         self.log.info(\"Ensuring background validation completes\")\n         self.wait_until(lambda: len(n1.getchainstates()['chainstates']) == 1)\n",
      "diff --git a/test/functional/feature_assumeutxo.py b/muts/feature_assumeutxo.mutant.49.py\nold mode 100755\nnew mode 100644\nindex 2995ece42f..8e08e8a179\n--- a/test/functional/feature_assumeutxo.py\n+++ b/muts/feature_assumeutxo.mutant.49.py\n@@ -305,7 +305,7 @@ class AssumeutxoTest(BitcoinTestFramework):\n         # If it does request such blocks, the snapshot_node will ignore requests it cannot fulfill, causing the ibd_node\n         # to stall. This stall could last for up to 10 min, ultimately resulting in an abrupt disconnection due to the\n         # ibd_node's perceived unresponsiveness.\n-        time.sleep(3)  # Sleep here because we can't detect when a node avoids requesting blocks from other peer.\n+        \n         assert_equal(len(ibd_node.getpeerinfo()[0]['inflight']), 0)\n \n         # Now disconnect nodes and finish background chain sync\n"
    ]
  },
  {
    "filename": "p2p_segwit.py",
    "diffs": [
      "diff --git a/test/functional/p2p_segwit.py b/muts/p2p_segwit.mutant.387.py\nold mode 100755\nnew mode 100644\nindex 9be53d2ab8..32693b252a\n--- a/test/functional/p2p_segwit.py\n+++ b/muts/p2p_segwit.mutant.387.py\n@@ -1639,7 +1639,7 @@ class SegWitTest(BitcoinTestFramework):\n                 sign_p2pk_witness_input(witness_script, tx, i, hashtype, temp_utxos[i].nValue, key)\n                 if (hashtype == SIGHASH_SINGLE and i >= num_outputs):\n                     used_sighash_single_out_of_bounds = True\n-            tx.rehash()\n+            \n             for i in range(num_outputs):\n                 temp_utxos.append(UTXO(tx.sha256, i, split_value))\n             temp_utxos = temp_utxos[num_inputs:]\n\n\n",
      "diff --git a/test/functional/p2p_segwit.py b/muts/p2p_segwit.mutant.133.py\nold mode 100755\nnew mode 100644\nindex 9be53d2ab8..1c56f9163a\n--- a/test/functional/p2p_segwit.py\n+++ b/muts/p2p_segwit.mutant.133.py\n@@ -782,7 +782,7 @@ class SegWitTest(BitcoinTestFramework):\n         tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, witness_script))\n         tx2.wit.vtxinwit.append(CTxInWitness())\n         tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_script]\n-        tx2.rehash()\n+        \n \n         block_3 = self.build_next_block()\n         self.update_witness_block_with_transactions(block_3, [tx, tx2], nonce=1)\n\n",
      "diff --git a/test/functional/p2p_segwit.py b/muts/p2p_segwit.mutant.43.py\nold mode 100755\nnew mode 100644\nindex 9be53d2ab8..09db244cc5\n--- a/test/functional/p2p_segwit.py\n+++ b/muts/p2p_segwit.mutant.43.py\n@@ -378,7 +378,7 @@ class SegWitTest(BitcoinTestFramework):\n         test_witness_block(self.nodes[0], self.test_node, block1, True)\n \n         block2 = self.build_next_block()\n-        block2.solve()\n+        \n \n         self.test_node.announce_block_and_wait_for_getdata(block2, use_header=True)\n         assert self.test_node.last_message[\"getdata\"].inv[0].type == blocktype\n\n",
      "diff --git a/test/functional/p2p_segwit.py b/muts/p2p_segwit.mutant.364.py\nold mode 100755\nnew mode 100644\nindex 9be53d2ab8..ce2c5b8ff8\n--- a/test/functional/p2p_segwit.py\n+++ b/muts/p2p_segwit.mutant.364.py\n@@ -1572,7 +1572,7 @@ class SegWitTest(BitcoinTestFramework):\n                                           'but finished with a false/empty top stack element')\n \n                 # Too-small input value\n-                sign_p2pk_witness_input(witness_script, tx, 0, hashtype, prev_utxo.nValue - 1, key)\n+                \n                 block.vtx.pop()  # remove last tx\n                 self.update_witness_block_with_transactions(block, [tx])\n                 test_witness_block(self.nodes[0], self.test_node, block, accepted=False,\n\n\n",
      "diff --git a/test/functional/p2p_segwit.py b/muts/p2p_segwit.mutant.224.py\nold mode 100755\nnew mode 100644\nindex 9be53d2ab8..c1c0ef3054\n--- a/test/functional/p2p_segwit.py\n+++ b/muts/p2p_segwit.mutant.224.py\n@@ -1071,7 +1071,7 @@ class SegWitTest(BitcoinTestFramework):\n         tx2.wit.vtxinwit.append(CTxInWitness())\n         # First try a 521-byte stack element\n         tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a' * (MAX_SCRIPT_ELEMENT_SIZE + 1), witness_script]\n-        tx2.rehash()\n+        \n \n         self.update_witness_block_with_transactions(block, [tx, tx2])\n         test_witness_block(self.nodes[0], self.test_node, block, accepted=False,\n\n",
      "diff --git a/test/functional/p2p_segwit.py b/muts/p2p_segwit.mutant.63.py\nold mode 100755\nnew mode 100644\nindex 9be53d2ab8..89ba54f9e3\n--- a/test/functional/p2p_segwit.py\n+++ b/muts/p2p_segwit.mutant.63.py\n@@ -493,7 +493,7 @@ class SegWitTest(BitcoinTestFramework):\n         p2sh_p2wsh_tx.vin = [CTxIn(COutPoint(txid, 1), CScript([script_pubkey]))]\n         p2sh_p2wsh_tx.vout = [CTxOut(value, CScript([OP_TRUE]))]\n         p2sh_p2wsh_tx.wit.vtxinwit.append(CTxInWitness())\n-        p2sh_p2wsh_tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([OP_TRUE])]\n+        \n         p2sh_p2wsh_tx.rehash()\n \n         for tx in [p2wsh_tx, p2sh_p2wsh_tx]:\n\n\n"
    ]
  },
  {
    "filename": "p2p_sendheaders.py",
    "diffs": [
      "diff --git a/test/functional/p2p_sendheaders.py b/muts/p2p_sendheaders.mutant.39.py\nold mode 100755\nnew mode 100644\nindex db706556d8..6507e5b49e\n--- a/test/functional/p2p_sendheaders.py\n+++ b/muts/p2p_sendheaders.mutant.39.py\n@@ -440,7 +440,7 @@ class SendHeadersTest(BitcoinTestFramework):\n         blocks = []\n         for _ in range(2):\n             blocks.append(create_block(tip, create_coinbase(height), block_time))\n-            blocks[-1].solve()\n+            \n             tip = blocks[-1].sha256\n             block_time += 1\n             height += 1\n\n\n",
      "diff --git a/test/functional/p2p_sendheaders.py b/muts/p2p_sendheaders.mutant.12.py\nold mode 100755\nnew mode 100644\nindex db706556d8..fa29c6c8a8\n--- a/test/functional/p2p_sendheaders.py\n+++ b/muts/p2p_sendheaders.mutant.12.py\n@@ -158,7 +158,7 @@ class BaseNode(P2PInterface):\n     def clear_block_announcements(self):\n         with p2p_lock:\n             self.block_announced = False\n-            self.last_message.pop(\"inv\", None)\n+            \n             self.last_message.pop(\"headers\", None)\n             self.recent_headers_announced = []\n \n\n",
      "diff --git a/test/functional/p2p_sendheaders.py b/muts/p2p_sendheaders.mutant.23.py\nold mode 100755\nnew mode 100644\nindex db706556d8..2ff3b30cda\n--- a/test/functional/p2p_sendheaders.py\n+++ b/muts/p2p_sendheaders.mutant.23.py\n@@ -251,7 +251,7 @@ class SendHeadersTest(BitcoinTestFramework):\n         test_node.send_get_headers(locator=[], hashstop=int(block.hash, 16))\n         test_node.sync_with_ping()\n         assert_equal(test_node.block_announced, False)\n-        inv_node.clear_block_announcements()\n+        \n         test_node.send_message(msg_block(block))\n         inv_node.check_last_inv_announcement(inv=[int(block.hash, 16)])\n \n\n",
      "diff --git a/test/functional/p2p_sendheaders.py b/muts/p2p_sendheaders.mutant.27.py\nold mode 100755\nnew mode 100644\nindex db706556d8..420934f831\n--- a/test/functional/p2p_sendheaders.py\n+++ b/muts/p2p_sendheaders.mutant.27.py\n@@ -290,7 +290,7 @@ class SendHeadersTest(BitcoinTestFramework):\n                 test_node.wait_for_getdata([new_block.sha256])\n                 test_node.send_and_ping(msg_block(new_block))  # make sure this block is processed\n                 inv_node.wait_until(lambda: inv_node.block_announced)\n-                inv_node.clear_block_announcements()\n+                \n                 test_node.clear_block_announcements()\n \n         self.log.info(\"Part 1: success!\")\n\n",
      "diff --git a/test/functional/p2p_sendheaders.py b/muts/p2p_sendheaders.mutant.0.py\nold mode 100755\nnew mode 100644\nindex db706556d8..be1428b0f9\n--- a/test/functional/p2p_sendheaders.py\n+++ b/muts/p2p_sendheaders.mutant.0.py\n@@ -39,7 +39,7 @@ b. node mines a block [expect: tip header]\n c. for N in 1, ..., 10:\n    * for announce-type in {inv, header}\n      - peer mines N blocks, announces with announce-type\n-       [ expect: getheaders/getdata or getdata, deliver block(s) ]\n+       \n      - node mines a block [ expect: 1 header ]\n \n Part 3: Headers announcements stop after large reorg and resume after getheaders or inv from peer.\n\n",
      "diff --git a/test/functional/p2p_sendheaders.py b/muts/p2p_sendheaders.mutant.13.py\nold mode 100755\nnew mode 100644\nindex db706556d8..9a2410f73c\n--- a/test/functional/p2p_sendheaders.py\n+++ b/muts/p2p_sendheaders.mutant.13.py\n@@ -159,7 +159,7 @@ class BaseNode(P2PInterface):\n         with p2p_lock:\n             self.block_announced = False\n             self.last_message.pop(\"inv\", None)\n-            self.last_message.pop(\"headers\", None)\n+            \n             self.recent_headers_announced = []\n \n \n\n",
      "diff --git a/test/functional/p2p_sendheaders.py b/muts/p2p_sendheaders.mutant.14.py\nold mode 100755\nnew mode 100644\nindex db706556d8..bdd911c96c\n--- a/test/functional/p2p_sendheaders.py\n+++ b/muts/p2p_sendheaders.mutant.14.py\n@@ -171,7 +171,7 @@ class BaseNode(P2PInterface):\n         with p2p_lock:\n             assert_equal(self.recent_headers_announced, headers)\n             self.block_announced = False\n-            self.last_message.pop(\"headers\", None)\n+            \n             self.recent_headers_announced = []\n \n     def check_last_inv_announcement(self, inv):\n\n",
      "diff --git a/test/functional/p2p_sendheaders.py b/muts/p2p_sendheaders.mutant.10.py\nold mode 100755\nnew mode 100644\nindex db706556d8..3d21f6c181\n--- a/test/functional/p2p_sendheaders.py\n+++ b/muts/p2p_sendheaders.mutant.10.py\n@@ -150,7 +150,7 @@ class BaseNode(P2PInterface):\n         if len(message.headers):\n             self.block_announced = True\n             for x in message.headers:\n-                x.calc_sha256()\n+                \n                 # append because headers may be announced over multiple messages.\n                 self.recent_headers_announced.append(x.sha256)\n             self.last_blockhash_announced = message.headers[-1].sha256\n\n",
      "diff --git a/test/functional/p2p_sendheaders.py b/muts/p2p_sendheaders.mutant.25.py\nold mode 100755\nnew mode 100644\nindex db706556d8..6b4cf2b451\n--- a/test/functional/p2p_sendheaders.py\n+++ b/muts/p2p_sendheaders.mutant.25.py\n@@ -280,7 +280,7 @@ class SendHeadersTest(BitcoinTestFramework):\n                 test_node.clear_block_announcements()  # since we requested headers...\n             elif i == 2:\n                 # this time announce own block via headers\n-                inv_node.clear_block_announcements()\n+                \n                 height = self.nodes[0].getblockcount()\n                 last_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time']\n                 block_time = last_time + 1\n\n\n"
    ]
  },
  {
    "filename": "p2p_sendtxrcncl.py",
    "diffs": [
      "diff --git a/test/functional/p2p_sendtxrcncl.py b/muts/p2p_sendtxrcncl.mutant.20.py\nold mode 100755\nnew mode 100644\nindex 2c7216b5ca..cd0c2874a5\n--- a/test/functional/p2p_sendtxrcncl.py\n+++ b/muts/p2p_sendtxrcncl.mutant.20.py\n@@ -146,7 +146,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         peer = self.nodes[0].add_outbound_p2p_connection(\n             SendTxrcnclReceiver(), wait_for_verack=True, p2p_idx=0, connection_type=\"addr-fetch\")\n         assert not peer.sendtxrcncl_msg_received\n-        self.nodes[0].disconnect_p2ps()\n+        \n \n         self.log.info('SENDTXRCNCL not sent if -txreconciliation flag is not set')\n         self.restart_node(0, [])\n\n",
      "diff --git a/test/functional/p2p_sendtxrcncl.py b/muts/p2p_sendtxrcncl.mutant.30.py\nold mode 100755\nnew mode 100644\nindex 2c7216b5ca..92bfefd6ae\n--- a/test/functional/p2p_sendtxrcncl.py\n+++ b/muts/p2p_sendtxrcncl.mutant.30.py\n@@ -177,7 +177,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         peer = self.nodes[0].add_p2p_connection(PeerNoVerack(), send_version=True, wait_for_verack=False)\n         with self.nodes[0].assert_debug_log(['ignored, as our node does not have txreconciliation enabled']):\n             peer.send_message(create_sendtxrcncl_msg())\n-        self.nodes[0].disconnect_p2ps()\n+        \n \n         self.restart_node(0, [\"-txreconciliation\"])\n \n\n",
      "diff --git a/test/functional/p2p_sendtxrcncl.py b/muts/p2p_sendtxrcncl.mutant.24.py\nold mode 100755\nnew mode 100644\nindex 2c7216b5ca..3ca5f4043a\n--- a/test/functional/p2p_sendtxrcncl.py\n+++ b/muts/p2p_sendtxrcncl.mutant.24.py\n@@ -158,7 +158,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         self.restart_node(0, [\"-txreconciliation\", \"-blocksonly\"])\n         peer = self.nodes[0].add_p2p_connection(SendTxrcnclReceiver(), send_version=True, wait_for_verack=True)\n         assert not peer.sendtxrcncl_msg_received\n-        self.nodes[0].disconnect_p2ps()\n+        \n \n         # Check everything concerning *receiving* SENDTXRCNCL\n         # First, receiving from *inbound*.\n\n",
      "diff --git a/test/functional/p2p_sendtxrcncl.py b/muts/p2p_sendtxrcncl.mutant.41.py\nold mode 100755\nnew mode 100644\nindex 2c7216b5ca..d791b98898\n--- a/test/functional/p2p_sendtxrcncl.py\n+++ b/muts/p2p_sendtxrcncl.mutant.41.py\n@@ -220,7 +220,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         with self.nodes[0].assert_debug_log(['Forget txreconciliation state of peer']):\n             peer.send_message(create_sendtxrcncl_msg())\n             peer.send_message(msg_verack())\n-        self.nodes[0].disconnect_p2ps()\n+        \n \n         # Now, *receiving* from *outbound*.\n         self.log.info('SENDTXRCNCL if block-relay-only triggers a disconnect')\n\n",
      "diff --git a/test/functional/p2p_sendtxrcncl.py b/muts/p2p_sendtxrcncl.mutant.34.py\nold mode 100755\nnew mode 100644\nindex 2c7216b5ca..02c6500167\n--- a/test/functional/p2p_sendtxrcncl.py\n+++ b/muts/p2p_sendtxrcncl.mutant.34.py\n@@ -195,7 +195,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         peer = self.nodes[0].add_p2p_connection(PeerNoVerack(), send_version=True, wait_for_verack=False)\n         with self.nodes[0].assert_debug_log(['Register peer=1']):\n             peer.send_message(sendtxrcncl_higher_version)\n-        self.nodes[0].disconnect_p2ps()\n+        \n \n         self.log.info('unexpected SENDTXRCNCL is ignored')\n         peer = self.nodes[0].add_p2p_connection(PeerNoVerack(), send_version=False, wait_for_verack=False)\n\n",
      "diff --git a/test/functional/p2p_sendtxrcncl.py b/muts/p2p_sendtxrcncl.mutant.11.py\nold mode 100755\nnew mode 100644\nindex 2c7216b5ca..9cbd0f6bef\n--- a/test/functional/p2p_sendtxrcncl.py\n+++ b/muts/p2p_sendtxrcncl.mutant.11.py\n@@ -95,7 +95,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         peer.send_message(pre_wtxid_version_msg)\n         peer.wait_for_verack()\n         assert not peer.sendtxrcncl_msg_received\n-        self.nodes[0].disconnect_p2ps()\n+        \n \n         self.log.info('SENDTXRCNCL for fRelay=false should not be sent')\n         peer = self.nodes[0].add_p2p_connection(SendTxrcnclReceiver(), send_version=False, wait_for_verack=False)\n\n",
      "diff --git a/test/functional/p2p_sendtxrcncl.py b/muts/p2p_sendtxrcncl.mutant.8.py\nold mode 100755\nnew mode 100644\nindex 2c7216b5ca..aec03d0688\n--- a/test/functional/p2p_sendtxrcncl.py\n+++ b/muts/p2p_sendtxrcncl.mutant.8.py\n@@ -75,7 +75,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         peer = self.nodes[0].add_p2p_connection(SendTxrcnclReceiver(), send_version=True, wait_for_verack=True)\n         assert peer.sendtxrcncl_msg_received\n         assert_equal(peer.sendtxrcncl_msg_received.version, 1)\n-        self.nodes[0].disconnect_p2ps()\n+        \n \n         self.log.info('SENDTXRCNCL should be sent before VERACK')\n         peer = self.nodes[0].add_p2p_connection(PeerTrackMsgOrder(), send_version=True, wait_for_verack=True)\n\n",
      "diff --git a/test/functional/p2p_sendtxrcncl.py b/muts/p2p_sendtxrcncl.mutant.9.py\nold mode 100755\nnew mode 100644\nindex 2c7216b5ca..2ac320bac2\n--- a/test/functional/p2p_sendtxrcncl.py\n+++ b/muts/p2p_sendtxrcncl.mutant.9.py\n@@ -83,7 +83,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         verack_index = [i for i, msg in enumerate(peer.messages) if msg.msgtype == b'verack'][0]\n         sendtxrcncl_index = [i for i, msg in enumerate(peer.messages) if msg.msgtype == b'sendtxrcncl'][0]\n         assert sendtxrcncl_index < verack_index\n-        self.nodes[0].disconnect_p2ps()\n+        \n \n         self.log.info('SENDTXRCNCL on pre-WTXID version should not be sent')\n         peer = self.nodes[0].add_p2p_connection(SendTxrcnclReceiver(), send_version=False, wait_for_verack=False)\n\n",
      "diff --git a/test/functional/p2p_sendtxrcncl.py b/muts/p2p_sendtxrcncl.mutant.39.py\nold mode 100755\nnew mode 100644\nindex 2c7216b5ca..6abab5aa10\n--- a/test/functional/p2p_sendtxrcncl.py\n+++ b/muts/p2p_sendtxrcncl.mutant.39.py\n@@ -218,7 +218,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         self.log.info('SENDTXRCNCL without WTXIDRELAY is ignored (recon state is erased after VERACK)')\n         peer = self.nodes[0].add_p2p_connection(PeerNoVerack(wtxidrelay=False), send_version=True, wait_for_verack=False)\n         with self.nodes[0].assert_debug_log(['Forget txreconciliation state of peer']):\n-            peer.send_message(create_sendtxrcncl_msg())\n+            \n             peer.send_message(msg_verack())\n         self.nodes[0].disconnect_p2ps()\n \n\n",
      "diff --git a/test/functional/p2p_sendtxrcncl.py b/muts/p2p_sendtxrcncl.mutant.19.py\nold mode 100755\nnew mode 100644\nindex 2c7216b5ca..8fd2b59ee3\n--- a/test/functional/p2p_sendtxrcncl.py\n+++ b/muts/p2p_sendtxrcncl.mutant.19.py\n@@ -140,7 +140,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         self.log.info(\"SENDTXRCNCL should not be sent if feeler\")\n         peer = self.nodes[0].add_outbound_p2p_connection(P2PFeelerReceiver(), p2p_idx=0, connection_type=\"feeler\")\n         assert not peer.sendtxrcncl_msg_received\n-        self.nodes[0].disconnect_p2ps()\n+        \n \n         self.log.info(\"SENDTXRCNCL should not be sent if addrfetch\")\n         peer = self.nodes[0].add_outbound_p2p_connection(\n\n",
      "diff --git a/test/functional/p2p_sendtxrcncl.py b/muts/p2p_sendtxrcncl.mutant.16.py\nold mode 100755\nnew mode 100644\nindex 2c7216b5ca..66a0f4f2ab\n--- a/test/functional/p2p_sendtxrcncl.py\n+++ b/muts/p2p_sendtxrcncl.mutant.16.py\n@@ -121,7 +121,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         peer.wait_for_verack()\n         assert peer.nServices & NODE_BLOOM != 0\n         assert not peer.sendtxrcncl_msg_received\n-        self.nodes[0].disconnect_p2ps()\n+        \n \n         # Now, *sending* to *outbound*.\n         self.log.info('SENDTXRCNCL sent to an outbound')\n\n",
      "diff --git a/test/functional/p2p_sendtxrcncl.py b/muts/p2p_sendtxrcncl.mutant.22.py\nold mode 100755\nnew mode 100644\nindex 2c7216b5ca..5963708da0\n--- a/test/functional/p2p_sendtxrcncl.py\n+++ b/muts/p2p_sendtxrcncl.mutant.22.py\n@@ -152,7 +152,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         self.restart_node(0, [])\n         peer = self.nodes[0].add_p2p_connection(SendTxrcnclReceiver(), send_version=True, wait_for_verack=True)\n         assert not peer.sendtxrcncl_msg_received\n-        self.nodes[0].disconnect_p2ps()\n+        \n \n         self.log.info('SENDTXRCNCL not sent if blocksonly is set')\n         self.restart_node(0, [\"-txreconciliation\", \"-blocksonly\"])\n\n",
      "diff --git a/test/functional/p2p_sendtxrcncl.py b/muts/p2p_sendtxrcncl.mutant.23.py\nold mode 100755\nnew mode 100644\nindex 2c7216b5ca..c02f1b3dab\n--- a/test/functional/p2p_sendtxrcncl.py\n+++ b/muts/p2p_sendtxrcncl.mutant.23.py\n@@ -155,7 +155,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         self.nodes[0].disconnect_p2ps()\n \n         self.log.info('SENDTXRCNCL not sent if blocksonly is set')\n-        self.restart_node(0, [\"-txreconciliation\", \"-blocksonly\"])\n+        \n         peer = self.nodes[0].add_p2p_connection(SendTxrcnclReceiver(), send_version=True, wait_for_verack=True)\n         assert not peer.sendtxrcncl_msg_received\n         self.nodes[0].disconnect_p2ps()\n\n",
      "diff --git a/test/functional/p2p_sendtxrcncl.py b/muts/p2p_sendtxrcncl.mutant.13.py\nold mode 100755\nnew mode 100644\nindex 2c7216b5ca..eb4b5d6a4b\n--- a/test/functional/p2p_sendtxrcncl.py\n+++ b/muts/p2p_sendtxrcncl.mutant.13.py\n@@ -107,7 +107,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         peer.send_message(no_txrelay_version_msg)\n         peer.wait_for_verack()\n         assert not peer.sendtxrcncl_msg_received\n-        self.nodes[0].disconnect_p2ps()\n+        \n \n         self.log.info('SENDTXRCNCL for fRelay=false should not be sent (with NODE_BLOOM offered)')\n         self.restart_node(0, [\"-peerbloomfilters\", \"-txreconciliation\"])\n\n",
      "diff --git a/test/functional/p2p_sendtxrcncl.py b/muts/p2p_sendtxrcncl.mutant.37.py\nold mode 100755\nnew mode 100644\nindex 2c7216b5ca..b1bfd8ee6f\n--- a/test/functional/p2p_sendtxrcncl.py\n+++ b/muts/p2p_sendtxrcncl.mutant.37.py\n@@ -207,7 +207,7 @@ class SendTxRcnclTest(BitcoinTestFramework):\n         peer.send_message(old_version_msg)\n         with self.nodes[0].assert_debug_log(['Ignore unexpected txreconciliation signal']):\n             peer.send_message(create_sendtxrcncl_msg())\n-        self.nodes[0].disconnect_p2ps()\n+        \n \n         self.log.info('sending SENDTXRCNCL after sending VERACK triggers a disconnect')\n         peer = self.nodes[0].add_p2p_connection(P2PInterface())\n\n\n"
    ]
  },
  {
    "filename": "interface_rest.py",
    "diffs": [
      "diff --git a/test/functional/interface_rest.py b/muts/interface_rest.mutant.6.py\nold mode 100755\nnew mode 100644\nindex ba6e960476..4baf5cd5cd\n--- a/test/functional/interface_rest.py\n+++ b/muts/interface_rest.mutant.6.py\n@@ -97,7 +97,7 @@ class RESTTest (BitcoinTestFramework):\n \n         self.log.info(\"Broadcast test transaction and sync nodes\")\n         txid = self.wallet.send_to(from_node=self.nodes[0], scriptPubKey=getnewdestination()[1], amount=int(0.1 * COIN))[\"txid\"]\n-        self.sync_all()\n+        \n \n         self.log.info(\"Test the /tx URI\")\n \n",
      "diff --git a/test/functional/interface_rest.py b/muts/interface_rest.mutant.11.py\nold mode 100755\nnew mode 100644\nindex ba6e960476..16bb392d5a\n--- a/test/functional/interface_rest.py\n+++ b/muts/interface_rest.mutant.11.py\n@@ -178,7 +178,7 @@ class RESTTest (BitcoinTestFramework):\n         # get the spent output to later check for utxo (should be spent by then)\n         spent = (json_obj['vin'][0]['txid'], json_obj['vin'][0]['vout'])\n         # get n of 0.1 outpoint\n-        n, = filter_output_indices_by_value(json_obj['vout'], Decimal('0.1'))\n+        \n         spending = (txid, n)\n \n         json_obj = self.test_rest_request(f\"/getutxos/{spending[0]}-{spending[1]}\")\n",
      "diff --git a/test/functional/interface_rest.py b/muts/interface_rest.mutant.10.py\nold mode 100755\nnew mode 100644\nindex ba6e960476..c07f95c4c7\n--- a/test/functional/interface_rest.py\n+++ b/muts/interface_rest.mutant.10.py\n@@ -158,7 +158,7 @@ class RESTTest (BitcoinTestFramework):\n         bin_request = b'\\x01\\x02'\n         for txid, n in [spending, spent]:\n             bin_request += bytes.fromhex(txid)\n-            bin_request += n.to_bytes(4, 'little')\n+            \n \n         bin_response = self.test_rest_request(\"/getutxos\", http_method='POST', req_type=ReqType.BIN, body=bin_request, ret_type=RetType.BYTES)\n         chain_height = int.from_bytes(bin_response[0:4], 'little')\n",
      "diff --git a/test/functional/interface_rest.py b/muts/interface_rest.mutant.20.py\nold mode 100755\nnew mode 100644\nindex ba6e960476..e8d3bff494\n--- a/test/functional/interface_rest.py\n+++ b/muts/interface_rest.mutant.20.py\n@@ -332,7 +332,7 @@ class RESTTest (BitcoinTestFramework):\n             utxo_to_spend = self.wallet.get_utxo(txid=input_txid)\n             txs.append(self.wallet.send_self_transfer(from_node=self.nodes[0], utxo_to_spend=utxo_to_spend)['txid'])\n             input_txid = txs[-1]\n-        self.sync_all()\n+        \n \n         # Check that there are exactly 3 transactions in the TX memory pool before generating the block\n         json_obj = self.test_rest_request(\"/mempool/info\")\n"
    ]
  },
  {
    "filename": "wallet_send.py",
    "diffs": [
      "diff --git a/test/functional/wallet_send.py b/muts/wallet_send.mutant.8.py\nold mode 100755\nnew mode 100644\nindex 2d0aad3b5d..e3d2fd886f\n--- a/test/functional/wallet_send.py\n+++ b/muts/wallet_send.mutant.8.py\n@@ -203,7 +203,7 @@ class WalletSendTest(BitcoinTestFramework):\n                 \"range\": [0, 100],\n                 \"active\": True\n             },{\n-                \"desc\": descsum_create(\"wpkh(\" + xpriv + \"/0/1/*)\"),\n+                \n                 \"timestamp\": \"now\",\n                 \"range\": [0, 100],\n                 \"active\": True,\n",
      "diff --git a/test/functional/wallet_send.py b/muts/wallet_send.mutant.26.py\nold mode 100755\nnew mode 100644\nindex 2d0aad3b5d..95b584104c\n--- a/test/functional/wallet_send.py\n+++ b/muts/wallet_send.mutant.26.py\n@@ -359,7 +359,7 @@ class WalletSendTest(BitcoinTestFramework):\n         msg = 'Invalid estimate_mode parameter, must be one of: \"unset\", \"economical\", \"conservative\"'\n         for target, mode in product([-1, 0], [\"btc/kb\", \"sat/b\"]):\n             self.test_send(from_wallet=w0, to_wallet=w1, amount=1, conf_target=target, estimate_mode=mode, expect_error=(-8, msg))\n-        for mode in [\"\", \"foo\", Decimal(\"3.141592\")]:\n+        \n             self.test_send(from_wallet=w0, to_wallet=w1, amount=1, conf_target=0.1, estimate_mode=mode, expect_error=(-8, msg))\n             self.test_send(from_wallet=w0, to_wallet=w1, amount=1, arg_conf_target=0.1, arg_estimate_mode=mode, expect_error=(-8, msg))\n             assert_raises_rpc_error(-8, msg, w0.send, {w1.getnewaddress(): 1}, 0.1, mode)\n",
      "diff --git a/test/functional/wallet_send.py b/muts/wallet_send.mutant.1.py\nold mode 100755\nnew mode 100644\nindex 2d0aad3b5d..3e02c49837\n--- a/test/functional/wallet_send.py\n+++ b/muts/wallet_send.mutant.1.py\n@@ -35,7 +35,7 @@ class WalletSendTest(BitcoinTestFramework):\n             [\"-walletrbf=1\"],\n             [\"-walletrbf=1\"]\n         ]\n-        getcontext().prec = 8 # Satoshi precision for Decimal\n+        \n \n     def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n"
    ]
  },
  {
    "filename": "mempool_package_rbf.py",
    "diffs": [
      "diff --git a/test/functional/mempool_package_rbf.py b/muts/mempool_package_rbf.mutant.59.py\nold mode 100755\nnew mode 100644\nindex f4d57262f2..c30410b2c2\n--- a/test/functional/mempool_package_rbf.py\n+++ b/muts/mempool_package_rbf.mutant.59.py\n@@ -551,7 +551,7 @@ class PackageRBFTest(BitcoinTestFramework):\n         assert_equal(set(submitres2[\"replaced-transactions\"]), set([parent1[\"txid\"], child1[\"txid\"]]))\n         self.assert_mempool_contents([parent2[\"tx\"], child2[\"tx\"]])\n \n-        self.generate(node, 1)\n+        \n \n     def test_child_conflicts_parent_mempool_ancestor(self):\n         fill_mempool(self, self.nodes[0])\n",
      "diff --git a/test/functional/mempool_package_rbf.py b/muts/mempool_package_rbf.mutant.7.py\nold mode 100755\nnew mode 100644\nindex f4d57262f2..ba8ccef5e9\n--- a/test/functional/mempool_package_rbf.py\n+++ b/muts/mempool_package_rbf.mutant.7.py\n@@ -114,7 +114,7 @@ class PackageRBFTest(BitcoinTestFramework):\n         self.assert_mempool_contents(expected=package_txns1)\n \n         # Make sure 2nd node gets set up for basic package RBF\n-        self.sync_all()\n+        \n \n         # Test run rejected because conflicts are not allowed in subpackage evaluation\n         testres = node.testmempoolaccept(package_hex2)\n",
      "diff --git a/test/functional/mempool_package_rbf.py b/muts/mempool_package_rbf.mutant.8.py\nold mode 100755\nnew mode 100644\nindex f4d57262f2..d74f69be58\n--- a/test/functional/mempool_package_rbf.py\n+++ b/muts/mempool_package_rbf.mutant.8.py\n@@ -126,7 +126,7 @@ class PackageRBFTest(BitcoinTestFramework):\n         self.assert_mempool_contents(expected=package_txns2)\n \n         # Make sure 2nd node gets a basic package RBF over p2p\n-        self.sync_all()\n+        \n \n         self.generate(node, 1)\n \n",
      "diff --git a/test/functional/mempool_package_rbf.py b/muts/mempool_package_rbf.mutant.61.py\nold mode 100755\nnew mode 100644\nindex f4d57262f2..ab7fa19867\n--- a/test/functional/mempool_package_rbf.py\n+++ b/muts/mempool_package_rbf.mutant.61.py\n@@ -556,7 +556,7 @@ class PackageRBFTest(BitcoinTestFramework):\n     def test_child_conflicts_parent_mempool_ancestor(self):\n         fill_mempool(self, self.nodes[0])\n         # Reset coins since we filled the mempool with current coins\n-        self.coins = self.wallet.get_utxos(mark_as_spent=False, confirmed_only=True)\n+        \n \n         self.log.info(\"Test that package RBF doesn't have issues with mempool<->package conflicts via inconsistency\")\n         node = self.nodes[0]\n"
    ]
  },
  {
    "filename": "p2p_compactblocks.py",
    "mutation_score": 0.752,
    "head": "48cf3da636089873ba7280e0d5b22eb81811d194",
    "diffs": [
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.107.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..f603bc9edc\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.107.py\n@@ -894,7 +894,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n             self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n \n             delivery_peer.clear_getblocktxn()\n-            inbound_peer.clear_getblocktxn()\n+            \n             outbound_peer.clear_getblocktxn()\n \n \n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.58.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..42e3f94639\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.58.py\n@@ -468,7 +468,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n \n         utxo = self.utxos.pop(0)\n         block = self.build_block_with_transactions(node, utxo, 5)\n-        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+        \n \n         # Now try interspersing the prefilled transactions\n         comp_block.initialize_from_block(block, prefill_list=[0, 1, 5], use_witness=True)\n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.39.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..b697e1dacd\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.39.py\n@@ -338,7 +338,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n \n     def check_compactblock_construction_from_block(self, header_and_shortids, block_hash, block):\n         # Check that we got the right block!\n-        header_and_shortids.header.calc_sha256()\n+        \n         assert_equal(header_and_shortids.header.sha256, block_hash)\n \n         # Make sure the prefilled_txn appears to have included the coinbase\n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.38.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..c2d64130e6\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.38.py\n@@ -310,7 +310,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n         block = from_hex(CBlock(), node.getblock(\"%064x\" % block_hash, False))\n         for tx in block.vtx:\n             tx.calc_sha256()\n-        block.rehash()\n+        \n \n         # Wait until the block was announced (via compact blocks)\n         test_node.wait_until(lambda: \"cmpctblock\" in test_node.last_message, timeout=30)\n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.18.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..ca302006ac\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.18.py\n@@ -124,7 +124,7 @@ class TestP2PConn(P2PInterface):\n         self.clear_block_announcement()\n         self.get_headers(locator, hashstop)\n         self.wait_until(self.received_block_announcement, timeout=30)\n-        self.clear_block_announcement()\n+        \n \n     # Block until a block announcement for a particular block hash is\n     # received.\n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.106.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..5381be55c9\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.106.py\n@@ -893,7 +893,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n             stalling_peer.send_and_ping(msg)\n             self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n \n-            delivery_peer.clear_getblocktxn()\n+            \n             inbound_peer.clear_getblocktxn()\n             outbound_peer.clear_getblocktxn()\n \n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.85.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..cf2c13c617\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.85.py\n@@ -702,7 +702,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n \n         block = self.build_block_with_transactions(node, utxo, 10)\n \n-        [l.clear_block_announcement() for l in listeners]\n+        \n \n         # serialize without witness (this block has no witnesses anyway).\n         # TODO: repeat this test with witness tx's to a segwit node.\n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.66.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..4eee700509\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.66.py\n@@ -522,7 +522,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n         utxo = self.utxos.pop(0)\n \n         block = self.build_block_with_transactions(node, utxo, 10)\n-        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+        \n         # Relay the first 5 transactions from the block in advance\n         for tx in block.vtx[1:6]:\n             test_node.send_message(msg_tx(tx))\n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.0.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..20eecd6e75\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.0.py\n@@ -2,7 +2,7 @@\n # Copyright (c) 2016-2022 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test compact blocks (BIP 152).\"\"\"\n+\n import random\n \n from test_framework.blocktools import (\n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.91.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..32e7976fe0\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.91.py\n@@ -733,7 +733,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n         # Now send the compact block with all transactions prefilled, and\n         # verify that we don't get disconnected.\n         comp_block = HeaderAndShortIDs()\n-        comp_block.initialize_from_block(block, prefill_list=[0, 1, 2, 3, 4], use_witness=True)\n+        \n         msg = msg_cmpctblock(comp_block.to_p2p())\n         test_node.send_and_ping(msg)\n \n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.108.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..a0ae41163f\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.108.py\n@@ -895,7 +895,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n \n             delivery_peer.clear_getblocktxn()\n             inbound_peer.clear_getblocktxn()\n-            outbound_peer.clear_getblocktxn()\n+            \n \n \n     def run_test(self):\n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.32.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..bf0100deed\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.32.py\n@@ -266,7 +266,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n \n     # This test actually causes bitcoind to (reasonably!) disconnect us, so do this last.\n     def test_invalid_cmpctblock_message(self):\n-        self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n+        \n         block = self.build_block_on_tip(self.nodes[0])\n \n         cmpct_block = P2PHeaderAndShortIDs()\n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.77.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..ab49e3aaa6\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.77.py\n@@ -625,7 +625,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n         hashPrevBlock = int(node.getblockhash(node.getblockcount() - 150), 16)\n         block = self.build_block_on_tip(node)\n         block.hashPrevBlock = hashPrevBlock\n-        block.solve()\n+        \n \n         comp_block = HeaderAndShortIDs()\n         comp_block.initialize_from_block(block)\n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.6.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..6aa6dabf1d\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.6.py\n@@ -85,7 +85,7 @@ class TestP2PConn(P2PInterface):\n     def on_headers(self, message):\n         self.block_announced = True\n         for x in self.last_message[\"headers\"].headers:\n-            x.calc_sha256()\n+            \n             self.announced_blockhashes.add(x.sha256)\n \n     def on_inv(self, message):\n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.87.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..a2a3d62d1e\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.87.py\n@@ -712,7 +712,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n             l.wait_until(lambda: \"cmpctblock\" in l.last_message, timeout=30)\n         with p2p_lock:\n             for l in listeners:\n-                l.last_message[\"cmpctblock\"].header_and_shortids.header.calc_sha256()\n+                \n                 assert_equal(l.last_message[\"cmpctblock\"].header_and_shortids.header.sha256, block.sha256)\n \n     # Test that we don't get disconnected if we relay a compact block with valid header,\n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.25.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..0a912915fe\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.25.py\n@@ -168,7 +168,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n         tx.vin.append(CTxIn(COutPoint(block.vtx[0].sha256, 0), b''))\n         for _ in range(10):\n             tx.vout.append(CTxOut(out_value, CScript([OP_TRUE])))\n-        tx.rehash()\n+        \n \n         block2 = self.build_block_on_tip(self.nodes[0])\n         block2.vtx.append(tx)\n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.35.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..69d952a470\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.35.py\n@@ -283,7 +283,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n     def test_compactblock_construction(self, test_node):\n         node = self.nodes[0]\n         # Generate a bunch of transactions.\n-        self.generate(node, COINBASE_MATURITY + 1)\n+        \n         num_transactions = 25\n \n         segwit_tx_generated = False\n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.64.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..fa42ecc3db\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.64.py\n@@ -495,7 +495,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n         # announced and verify reconstruction happens immediately.\n         utxo = self.utxos.pop(0)\n         block = self.build_block_with_transactions(node, utxo, 10)\n-        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+        \n         for tx in block.vtx[1:]:\n             test_node.send_message(msg_tx(tx))\n         test_node.sync_with_ping()\n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.10.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..bfdbf2f241\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.10.py\n@@ -102,7 +102,7 @@ class TestP2PConn(P2PInterface):\n         with p2p_lock:\n             self.block_announced = False\n             self.last_message.pop(\"inv\", None)\n-            self.last_message.pop(\"headers\", None)\n+            \n             self.last_message.pop(\"cmpctblock\", None)\n \n     def clear_getblocktxn(self):\n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.96.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..406684433c\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.96.py\n@@ -777,7 +777,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n         delivery_peer.send_and_ping(msg_cmpctblock(cmpct_block.to_p2p()))\n         assert_equal(int(node.getbestblockhash(), 16), block.sha256)\n \n-        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+        \n \n         # Now test that delivering an invalid compact block won't break relay\n \n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.71.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..d3e25a8de7\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.71.py\n@@ -580,7 +580,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n             msg = msg_getblocktxn()\n             msg.block_txn_request = BlockTransactionsRequest(int(block_hash, 16), [])\n             num_to_request = random.randint(1, len(block.vtx))\n-            msg.block_txn_request.from_absolute(sorted(random.sample(range(len(block.vtx)), num_to_request)))\n+            \n             test_node.send_message(msg)\n             test_node.wait_until(lambda: \"blocktxn\" in test_node.last_message, timeout=10)\n \n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.55.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..5a6be63e35\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.55.py\n@@ -455,7 +455,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n         utxo = self.utxos.pop(0)\n \n         block = self.build_block_with_transactions(node, utxo, 5)\n-        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+        \n         comp_block = HeaderAndShortIDs()\n         comp_block.initialize_from_block(block, use_witness=True)\n \n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.61.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..0d9102b100\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.61.py\n@@ -479,7 +479,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n         # Now try giving one transaction ahead of time.\n         utxo = self.utxos.pop(0)\n         block = self.build_block_with_transactions(node, utxo, 5)\n-        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+        \n         test_node.send_and_ping(msg_tx(block.vtx[1]))\n         assert block.vtx[1].hash in node.getrawmempool()\n \n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.92.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..03eb05d271\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.92.py\n@@ -746,7 +746,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n     def request_cb_announcements(self, peer):\n         node = self.nodes[0]\n         tip = node.getbestblockhash()\n-        peer.get_headers(locator=[int(tip, 16)], hashstop=0)\n+        \n         peer.send_and_ping(msg_sendcmpct(announce=True, version=2))\n \n     def test_compactblock_reconstruction_stalling_peer(self, stalling_peer, delivery_peer):\n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.89.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..e3e2510995\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.89.py\n@@ -726,7 +726,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n         del block.vtx[3]\n         block.hashMerkleRoot = block.calc_merkle_root()\n         # Drop the coinbase witness but include the witness commitment.\n-        add_witness_commitment(block)\n+        \n         block.vtx[0].wit.vtxinwit = []\n         block.solve()\n \n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.105.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..4d85bdff37\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.105.py\n@@ -891,7 +891,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n \n             # Nothing bad should happen if we get a late fill from the first peer...\n             stalling_peer.send_and_ping(msg)\n-            self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+            \n \n             delivery_peer.clear_getblocktxn()\n             inbound_peer.clear_getblocktxn()\n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.115.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..f0c7f2404c\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.115.py\n@@ -950,7 +950,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n         # (Post-segwit activation, blocks won't propagate from node0 to node1\n         # automatically, so don't bother testing a block announced to node0.)\n         self.log.info(\"Testing end-to-end block relay...\")\n-        self.request_cb_announcements(self.segwit_node)\n+        \n         self.request_cb_announcements(self.additional_segwit_node)\n         self.test_end_to_end_block_relay([self.segwit_node, self.additional_segwit_node])\n \n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.88.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..f0d39c2ec6\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.88.py\n@@ -724,7 +724,7 @@ class CompactBlocksTest(BitcoinTestFramework):\n \n         block = self.build_block_with_transactions(node, utxo, 5)\n         del block.vtx[3]\n-        block.hashMerkleRoot = block.calc_merkle_root()\n+        \n         # Drop the coinbase witness but include the witness commitment.\n         add_witness_commitment(block)\n         block.vtx[0].wit.vtxinwit = []\n",
      "diff --git a/test/functional/p2p_compactblocks.py b/muts/p2p_compactblocks.mutant.9.py\nold mode 100755\nnew mode 100644\nindex 49cf26d425..a5bae6d54b\n--- a/test/functional/p2p_compactblocks.py\n+++ b/muts/p2p_compactblocks.mutant.9.py\n@@ -101,7 +101,7 @@ class TestP2PConn(P2PInterface):\n     def clear_block_announcement(self):\n         with p2p_lock:\n             self.block_announced = False\n-            self.last_message.pop(\"inv\", None)\n+            \n             self.last_message.pop(\"headers\", None)\n             self.last_message.pop(\"cmpctblock\", None)\n \n"
    ]
  }
]