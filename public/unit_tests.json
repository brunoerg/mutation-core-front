[
    {
        "filename": "coinselector_tests.cpp",
        "head": "0ca1d1bf69ca364393e924cf41becfde1b68126c",
        "mutation_score": 0.7090909090909091,
        "diffs": [
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.168.cpp\nindex eb9c349c22..13f1646da7 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.168.cpp\n@@ -745,7 +745,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n \n     // test randomness\n     {\n-        available_coins.Clear();\n+        \n         for (int i2 = 0; i2 < 100; i2++)\n             add_coin(available_coins, *wallet, COIN);\n \n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.140.cpp\nindex eb9c349c22..b1da164ecd 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.140.cpp\n@@ -619,7 +619,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(available_coins, *wallet,  1*COIN);\n         add_coin(available_coins, *wallet,  2*COIN);\n         add_coin(available_coins, *wallet,  3*COIN);\n-        add_coin(available_coins, *wallet,  4*COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n+        \n         const auto result14 = KnapsackSolver(KnapsackGroupOutputs(available_coins, *wallet, filter_confirmed), 95 * CENT, CENT);\n         BOOST_CHECK(result14);\n         BOOST_CHECK_EQUAL(result14->GetSelectedValue(), 1 * COIN);  // we should get 1 BTC in 1 coin\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.154.cpp\nindex eb9c349c22..c4880ea508 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.154.cpp\n@@ -679,7 +679,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         // sometimes it will fail, and so we use the next biggest coin:\n         available_coins.Clear();\n         add_coin(available_coins, *wallet, CENT * 5 / 10);\n-        add_coin(available_coins, *wallet, CENT * 6 / 10);\n+        \n         add_coin(available_coins, *wallet, CENT * 7 / 10);\n         add_coin(available_coins, *wallet, 1111 * CENT);\n         const auto result20 = KnapsackSolver(KnapsackGroupOutputs(available_coins, *wallet, filter_confirmed), 1 * CENT, CENT);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.155.cpp\nindex eb9c349c22..aee391065e 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.155.cpp\n@@ -680,7 +680,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         available_coins.Clear();\n         add_coin(available_coins, *wallet, CENT * 5 / 10);\n         add_coin(available_coins, *wallet, CENT * 6 / 10);\n-        add_coin(available_coins, *wallet, CENT * 7 / 10);\n+        \n         add_coin(available_coins, *wallet, 1111 * CENT);\n         const auto result20 = KnapsackSolver(KnapsackGroupOutputs(available_coins, *wallet, filter_confirmed), 1 * CENT, CENT);\n         BOOST_CHECK(result20);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.141.cpp\nindex eb9c349c22..120f674790 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.141.cpp\n@@ -632,7 +632,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n \n         // empty the wallet and start again, now with fractions of a cent, to test small change avoidance\n \n-        available_coins.Clear();\n+        \n         add_coin(available_coins, *wallet, CENT * 1 / 10);\n         add_coin(available_coins, *wallet, CENT * 2 / 10);\n         add_coin(available_coins, *wallet, CENT * 3 / 10);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.19.cpp\nindex eb9c349c22..c530ff0b56 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.19.cpp\n@@ -181,7 +181,7 @@ static std::unique_ptr<CWallet> NewWallet(const node::NodeContext& m_node, const\n {\n     std::unique_ptr<CWallet> wallet = std::make_unique<CWallet>(m_node.chain.get(), wallet_name, CreateMockableWalletDatabase());\n     BOOST_CHECK(wallet->LoadWallet() == DBErrors::LOAD_OK);\n-    LOCK(wallet->cs_wallet);\n+    \n     wallet->SetWalletFlag(WALLET_FLAG_DESCRIPTORS);\n     wallet->SetupDescriptorScriptPubKeyMans();\n     return wallet;\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.33.cpp\nindex eb9c349c22..5a9b7c5920 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.33.cpp\n@@ -231,7 +231,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     BOOST_CHECK(result3);\n     BOOST_CHECK(EquivalentResult(expected_result, *result3));\n     BOOST_CHECK_EQUAL(result3->GetSelectedValue(), 5 * CENT);\n-    expected_result.Clear();\n+    \n \n     // Select 11 Cent, not possible\n     BOOST_CHECK(!SelectCoinsBnB(GroupCoins(utxo_pool), 11 * CENT, 0.5 * CENT));\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.157.cpp\nindex eb9c349c22..8584418386 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.157.cpp\n@@ -688,7 +688,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         BOOST_CHECK_EQUAL(result20->GetInputSet().size(), 1U);\n \n         // but sometimes it's possible, and we use an exact subset (0.4 + 0.6 = 1.0)\n-        available_coins.Clear();\n+        \n         add_coin(available_coins, *wallet, CENT * 4 / 10);\n         add_coin(available_coins, *wallet, CENT * 6 / 10);\n         add_coin(available_coins, *wallet, CENT * 8 / 10);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.143.cpp\nindex eb9c349c22..604fcbd08d 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.143.cpp\n@@ -634,7 +634,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n \n         available_coins.Clear();\n         add_coin(available_coins, *wallet, CENT * 1 / 10);\n-        add_coin(available_coins, *wallet, CENT * 2 / 10);\n+        \n         add_coin(available_coins, *wallet, CENT * 3 / 10);\n         add_coin(available_coins, *wallet, CENT * 4 / 10);\n         add_coin(available_coins, *wallet, CENT * 5 / 10);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.180.cpp\nindex eb9c349c22..2db880e9ed 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.180.cpp\n@@ -845,7 +845,7 @@ BOOST_AUTO_TEST_CASE(SelectCoins_test)\n         }\n \n         // Generate a random fee rate in the range of 100 - 400\n-        CFeeRate rate(rand.randrange(300) + 100);\n+        \n \n         // Generate a random target value between 1000 and wallet balance\n         CAmount target = rand.randrange(balance - 1000) + 1000;\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.142.cpp\nindex eb9c349c22..3640a60116 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.142.cpp\n@@ -633,7 +633,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         // empty the wallet and start again, now with fractions of a cent, to test small change avoidance\n \n         available_coins.Clear();\n-        add_coin(available_coins, *wallet, CENT * 1 / 10);\n+        \n         add_coin(available_coins, *wallet, CENT * 2 / 10);\n         add_coin(available_coins, *wallet, CENT * 3 / 10);\n         add_coin(available_coins, *wallet, CENT * 4 / 10);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.7.cpp\nindex eb9c349c22..261c3bda71 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.7.cpp\n@@ -82,7 +82,7 @@ static void add_coin(CoinsResult& available_coins, CWallet& wallet, const CAmoun\n     }\n     uint256 txid = tx.GetHash();\n \n-    LOCK(wallet.cs_wallet);\n+    \n     auto ret = wallet.mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(txid), std::forward_as_tuple(MakeTransactionRef(std::move(tx)), TxStateInactive{}));\n     assert(ret.second);\n     CWalletTx& wtx = (*ret.first).second;\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.36.cpp\nindex eb9c349c22..5c17cfcf2f 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.36.cpp\n@@ -243,7 +243,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     BOOST_CHECK(result4);\n     BOOST_CHECK_EQUAL(result4->GetSelectedValue(), 1 * CENT);\n     BOOST_CHECK(EquivalentResult(expected_result, *result4));\n-    expected_result.Clear();\n+    \n \n     // Cost of change is less than the difference between target value and utxo sum\n     BOOST_CHECK(!SelectCoinsBnB(GroupCoins(utxo_pool), 0.9 * CENT, 0));\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.152.cpp\nindex eb9c349c22..32cdf4a3b1 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.152.cpp\n@@ -677,7 +677,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         // we need to try finding an exact subset anyway\n \n         // sometimes it will fail, and so we use the next biggest coin:\n-        available_coins.Clear();\n+        \n         add_coin(available_coins, *wallet, CENT * 5 / 10);\n         add_coin(available_coins, *wallet, CENT * 6 / 10);\n         add_coin(available_coins, *wallet, CENT * 7 / 10);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.146.cpp\nindex eb9c349c22..42270fccf9 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.146.cpp\n@@ -637,7 +637,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(available_coins, *wallet, CENT * 2 / 10);\n         add_coin(available_coins, *wallet, CENT * 3 / 10);\n         add_coin(available_coins, *wallet, CENT * 4 / 10);\n-        add_coin(available_coins, *wallet, CENT * 5 / 10);\n+        \n \n         // try making 1 * CENT from the 1.5 * CENT\n         // we'll get change smaller than CENT whatever happens, so can expect CENT exactly\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.147.cpp\nindex eb9c349c22..c4279034b3 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.147.cpp\n@@ -646,7 +646,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         BOOST_CHECK_EQUAL(result16->GetSelectedValue(), CENT);\n \n         // but if we add a bigger coin, small change is avoided\n-        add_coin(available_coins, *wallet, 1111*CENT);\n+        \n \n         // try making 1 from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5\n         const auto result17 = KnapsackSolver(KnapsackGroupOutputs(available_coins, *wallet, filter_confirmed), 1 * CENT, CENT);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.153.cpp\nindex eb9c349c22..30187f39bc 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.153.cpp\n@@ -678,7 +678,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n \n         // sometimes it will fail, and so we use the next biggest coin:\n         available_coins.Clear();\n-        add_coin(available_coins, *wallet, CENT * 5 / 10);\n+        \n         add_coin(available_coins, *wallet, CENT * 6 / 10);\n         add_coin(available_coins, *wallet, CENT * 7 / 10);\n         add_coin(available_coins, *wallet, 1111 * CENT);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.37.cpp\nindex eb9c349c22..7289896391 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.37.cpp\n@@ -247,7 +247,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n \n     // Cost of change is less than the difference between target value and utxo sum\n     BOOST_CHECK(!SelectCoinsBnB(GroupCoins(utxo_pool), 0.9 * CENT, 0));\n-    expected_result.Clear();\n+    \n \n     // Select 10 Cent\n     add_coin(5 * CENT, 5, utxo_pool);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.145.cpp\nindex eb9c349c22..3bdd53db1a 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.145.cpp\n@@ -636,7 +636,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(available_coins, *wallet, CENT * 1 / 10);\n         add_coin(available_coins, *wallet, CENT * 2 / 10);\n         add_coin(available_coins, *wallet, CENT * 3 / 10);\n-        add_coin(available_coins, *wallet, CENT * 4 / 10);\n+        \n         add_coin(available_coins, *wallet, CENT * 5 / 10);\n \n         // try making 1 * CENT from the 1.5 * CENT\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.150.cpp\nindex eb9c349c22..e353d32c44 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.150.cpp\n@@ -664,7 +664,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n \n         // run the 'mtgox' test (see https://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n         // they tried to consolidate 10 50k coins into one 500k coin, and ended up with 50k in change\n-        available_coins.Clear();\n+        \n         for (int j = 0; j < 20; j++)\n             add_coin(available_coins, *wallet, 50000 * COIN);\n \n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.144.cpp\nindex eb9c349c22..8ed62e59a8 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.144.cpp\n@@ -635,7 +635,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         available_coins.Clear();\n         add_coin(available_coins, *wallet, CENT * 1 / 10);\n         add_coin(available_coins, *wallet, CENT * 2 / 10);\n-        add_coin(available_coins, *wallet, CENT * 3 / 10);\n+        \n         add_coin(available_coins, *wallet, CENT * 4 / 10);\n         add_coin(available_coins, *wallet, CENT * 5 / 10);\n \n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.34.cpp\nindex eb9c349c22..f99acc3b8b 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.34.cpp\n@@ -235,7 +235,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n \n     // Select 11 Cent, not possible\n     BOOST_CHECK(!SelectCoinsBnB(GroupCoins(utxo_pool), 11 * CENT, 0.5 * CENT));\n-    expected_result.Clear();\n+    \n \n     // Cost of change is greater than the difference between target value and utxo sum\n     add_coin(1 * CENT, 1, expected_result);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.84.cpp\nindex eb9c349c22..ba2073d5a1 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.84.cpp\n@@ -384,7 +384,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         available_coins.Clear();\n \n         // more coins should be selected when effective fee < long term fee\n-        coin_selection_params_bnb.m_effective_feerate = CFeeRate(3000);\n+        \n         coin_selection_params_bnb.m_long_term_feerate = CFeeRate(5000);\n \n         // Add selectable outputs, increasing their raw amounts by their input fee to make the effective value equal to the raw amount\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.122.cpp\nindex eb9c349c22..a71c316eb5 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.122.cpp\n@@ -482,7 +482,7 @@ BOOST_AUTO_TEST_CASE(bnb_sffo_restriction)\n     CoinsResult available_coins;\n     add_coin(available_coins, *wallet, COIN + params.m_cost_of_change, /*feerate=*/params.m_effective_feerate, /*nAge=*/6, /*fIsFromMe=*/true, /*nInput=*/0, /*spendable=*/true);\n     add_coin(available_coins, *wallet, 0.5 * COIN + params.m_cost_of_change, /*feerate=*/params.m_effective_feerate, /*nAge=*/6, /*fIsFromMe=*/true, /*nInput=*/0, /*spendable=*/true);\n-    add_coin(available_coins, *wallet, 0.5 * COIN, /*feerate=*/params.m_effective_feerate, /*nAge=*/6, /*fIsFromMe=*/true, /*nInput=*/0, /*spendable=*/true);\n+    \n     // Knapsack will only find a changeless solution on an exact match to the satoshi, SRD doesn\u2019t look for changeless\n     // If BnB were run, it would produce a single input solution with the best waste score\n     auto result = WITH_LOCK(wallet->cs_wallet, return SelectCoins(*wallet, available_coins, /*pre_set_inputs=*/{}, COIN, /*coin_control=*/{}, params));\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.85.cpp\nindex eb9c349c22..8adfbf3fb5 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.85.cpp\n@@ -385,7 +385,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n \n         // more coins should be selected when effective fee < long term fee\n         coin_selection_params_bnb.m_effective_feerate = CFeeRate(3000);\n-        coin_selection_params_bnb.m_long_term_feerate = CFeeRate(5000);\n+        \n \n         // Add selectable outputs, increasing their raw amounts by their input fee to make the effective value equal to the raw amount\n         input_fee = coin_selection_params_bnb.m_effective_feerate.GetFee(/*num_bytes=*/68); // bech32 input size (default test output type)\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.44.cpp\nindex eb9c349c22..eda1186af2 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.44.cpp\n@@ -263,7 +263,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n \n     // Select 0.25 Cent, not possible\n     BOOST_CHECK(!SelectCoinsBnB(GroupCoins(utxo_pool), 0.25 * CENT, 0.5 * CENT));\n-    expected_result.Clear();\n+    \n \n     // Iteration exhaustion test\n     CAmount target = make_hard_case(17, utxo_pool);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.256.cpp\nindex eb9c349c22..49fc2329b4 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.256.cpp\n@@ -1347,7 +1347,7 @@ BOOST_AUTO_TEST_CASE(srd_tests)\n             CoinsResult available_coins;\n             for (int j = 0; j < 10; ++j) {\n                 add_coin(available_coins, wallet, CAmount(1 * COIN));\n-                add_coin(available_coins, wallet, CAmount(2 * COIN));\n+                \n             }\n             return available_coins;\n         });\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.87.cpp\nindex eb9c349c22..6ce51c105e 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.87.cpp\n@@ -389,7 +389,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n \n         // Add selectable outputs, increasing their raw amounts by their input fee to make the effective value equal to the raw amount\n         input_fee = coin_selection_params_bnb.m_effective_feerate.GetFee(/*num_bytes=*/68); // bech32 input size (default test output type)\n-        add_coin(available_coins, *wallet, 10 * CENT + input_fee, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n+        \n         add_coin(available_coins, *wallet, 9 * CENT + input_fee, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n         add_coin(available_coins, *wallet, 1 * CENT + input_fee, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n \n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.120.cpp\nindex eb9c349c22..8c032a51db 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.120.cpp\n@@ -480,7 +480,7 @@ BOOST_AUTO_TEST_CASE(bnb_sffo_restriction)\n     params.m_min_change_target = params.m_cost_of_change + 1;\n     // Add spendable coin at the BnB selection upper bound\n     CoinsResult available_coins;\n-    add_coin(available_coins, *wallet, COIN + params.m_cost_of_change, /*feerate=*/params.m_effective_feerate, /*nAge=*/6, /*fIsFromMe=*/true, /*nInput=*/0, /*spendable=*/true);\n+    \n     add_coin(available_coins, *wallet, 0.5 * COIN + params.m_cost_of_change, /*feerate=*/params.m_effective_feerate, /*nAge=*/6, /*fIsFromMe=*/true, /*nInput=*/0, /*spendable=*/true);\n     add_coin(available_coins, *wallet, 0.5 * COIN, /*feerate=*/params.m_effective_feerate, /*nAge=*/6, /*fIsFromMe=*/true, /*nInput=*/0, /*spendable=*/true);\n     // Knapsack will only find a changeless solution on an exact match to the satoshi, SRD doesn\u2019t look for changeless\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.121.cpp\nindex eb9c349c22..74b4215e6a 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.121.cpp\n@@ -481,7 +481,7 @@ BOOST_AUTO_TEST_CASE(bnb_sffo_restriction)\n     // Add spendable coin at the BnB selection upper bound\n     CoinsResult available_coins;\n     add_coin(available_coins, *wallet, COIN + params.m_cost_of_change, /*feerate=*/params.m_effective_feerate, /*nAge=*/6, /*fIsFromMe=*/true, /*nInput=*/0, /*spendable=*/true);\n-    add_coin(available_coins, *wallet, 0.5 * COIN + params.m_cost_of_change, /*feerate=*/params.m_effective_feerate, /*nAge=*/6, /*fIsFromMe=*/true, /*nInput=*/0, /*spendable=*/true);\n+    \n     add_coin(available_coins, *wallet, 0.5 * COIN, /*feerate=*/params.m_effective_feerate, /*nAge=*/6, /*fIsFromMe=*/true, /*nInput=*/0, /*spendable=*/true);\n     // Knapsack will only find a changeless solution on an exact match to the satoshi, SRD doesn\u2019t look for changeless\n     // If BnB were run, it would produce a single input solution with the best waste score\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.79.cpp\nindex eb9c349c22..6b891b3ee9 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.79.cpp\n@@ -373,7 +373,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         // Add selectable outputs, increasing their raw amounts by their input fee to make the effective value equal to the raw amount\n         CAmount input_fee = coin_selection_params_bnb.m_effective_feerate.GetFee(/*num_bytes=*/68); // bech32 input size (default test output type)\n         add_coin(available_coins, *wallet, 10 * CENT + input_fee, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n-        add_coin(available_coins, *wallet, 9 * CENT + input_fee, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n+        \n         add_coin(available_coins, *wallet, 1 * CENT + input_fee, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n \n         expected_result.Clear();\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.118.cpp\nindex eb9c349c22..29a6977fa5 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.118.cpp\n@@ -475,7 +475,7 @@ BOOST_AUTO_TEST_CASE(bnb_sffo_restriction)\n             /*avoid_partial=*/ false,\n     };\n     params.m_subtract_fee_outputs = true;\n-    params.m_change_fee = params.m_effective_feerate.GetFee(params.change_output_size);\n+    \n     params.m_cost_of_change = params.m_discard_feerate.GetFee(params.change_spend_size) + params.m_change_fee;\n     params.m_min_change_target = params.m_cost_of_change + 1;\n     // Add spendable coin at the BnB selection upper bound\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.83.cpp\nindex eb9c349c22..fed4f7877d 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.83.cpp\n@@ -381,7 +381,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         CCoinControl coin_control;\n         const auto result11 = SelectCoins(*wallet, available_coins, /*pre_set_inputs=*/{}, 10 * CENT, coin_control, coin_selection_params_bnb);\n         BOOST_CHECK(EquivalentResult(expected_result, *result11));\n-        available_coins.Clear();\n+        \n \n         // more coins should be selected when effective fee < long term fee\n         coin_selection_params_bnb.m_effective_feerate = CFeeRate(3000);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.97.cpp\nindex eb9c349c22..797c8a0342 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.97.cpp\n@@ -406,7 +406,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n \n         // Add selectable outputs, increasing their raw amounts by their input fee to make the effective value equal to the raw amount\n         input_fee = coin_selection_params_bnb.m_effective_feerate.GetFee(/*num_bytes=*/68); // bech32 input size (default test output type)\n-        add_coin(available_coins, *wallet, 10 * CENT + input_fee, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n+        \n         add_coin(available_coins, *wallet, 9 * CENT + input_fee, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n         add_coin(available_coins, *wallet, 1 * CENT + input_fee, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n \n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.95.cpp\nindex eb9c349c22..838eea0585 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.95.cpp\n@@ -402,7 +402,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n \n         // pre selected coin should be selected even if disadvantageous\n         coin_selection_params_bnb.m_effective_feerate = CFeeRate(5000);\n-        coin_selection_params_bnb.m_long_term_feerate = CFeeRate(3000);\n+        \n \n         // Add selectable outputs, increasing their raw amounts by their input fee to make the effective value equal to the raw amount\n         input_fee = coin_selection_params_bnb.m_effective_feerate.GetFee(/*num_bytes=*/68); // bech32 input size (default test output type)\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.94.cpp\nindex eb9c349c22..2562d1d79c 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.94.cpp\n@@ -401,7 +401,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         available_coins.Clear();\n \n         // pre selected coin should be selected even if disadvantageous\n-        coin_selection_params_bnb.m_effective_feerate = CFeeRate(5000);\n+        \n         coin_selection_params_bnb.m_long_term_feerate = CFeeRate(3000);\n \n         // Add selectable outputs, increasing their raw amounts by their input fee to make the effective value equal to the raw amount\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.80.cpp\nindex eb9c349c22..49743d2d35 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.80.cpp\n@@ -374,7 +374,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         CAmount input_fee = coin_selection_params_bnb.m_effective_feerate.GetFee(/*num_bytes=*/68); // bech32 input size (default test output type)\n         add_coin(available_coins, *wallet, 10 * CENT + input_fee, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n         add_coin(available_coins, *wallet, 9 * CENT + input_fee, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n-        add_coin(available_coins, *wallet, 1 * CENT + input_fee, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n+        \n \n         expected_result.Clear();\n         add_coin(10 * CENT + input_fee, 2, expected_result);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.57.cpp\nindex eb9c349c22..952908e31f 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.57.cpp\n@@ -285,7 +285,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     add_coin(7 * CENT, 7, utxo_pool);\n     add_coin(2 * CENT, 7, utxo_pool);\n     for (int i = 0; i < 50000; ++i) {\n-        add_coin(5 * CENT, 7, utxo_pool);\n+        \n     }\n     const auto result8 = SelectCoinsBnB(GroupCoins(utxo_pool), 30 * CENT, 5000);\n     BOOST_CHECK(result8);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.43.cpp\nindex eb9c349c22..3497c96736 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.43.cpp\n@@ -259,7 +259,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     BOOST_CHECK(result5);\n     BOOST_CHECK(EquivalentResult(expected_result, *result5));\n     BOOST_CHECK_EQUAL(result5->GetSelectedValue(), 10 * CENT);\n-    expected_result.Clear();\n+    \n \n     // Select 0.25 Cent, not possible\n     BOOST_CHECK(!SelectCoinsBnB(GroupCoins(utxo_pool), 0.25 * CENT, 0.5 * CENT));\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.66.cpp\nindex eb9c349c22..a55cb6a25a 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.66.cpp\n@@ -333,7 +333,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         // Test fees subtracted from output:\n         available_coins.Clear();\n         add_coin(available_coins, *wallet, 1 * CENT, coin_selection_params_bnb.m_effective_feerate);\n-        available_coins.All().at(0).input_bytes = 40;\n+        \n         const auto result9 = SelectCoinsBnB(GroupCoins(available_coins.All()), 1 * CENT, coin_selection_params_bnb.m_cost_of_change);\n         BOOST_CHECK(result9);\n         BOOST_CHECK_EQUAL(result9->GetSelectedValue(), 1 * CENT);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.117.cpp\nindex eb9c349c22..c27d716d3a 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.117.cpp\n@@ -460,7 +460,7 @@ BOOST_AUTO_TEST_CASE(bnb_sffo_restriction)\n     // Verify the coin selection process does not produce a BnB solution when SFFO is enabled.\n     // This is currently problematic because it could require a change output. And BnB is specialized on changeless solutions.\n     std::unique_ptr<CWallet> wallet = NewWallet(m_node);\n-    WITH_LOCK(wallet->cs_wallet, wallet->SetLastBlockProcessed(300, uint256{})); // set a high block so internal UTXOs are selectable\n+    \n \n     FastRandomContext rand{};\n     CoinSelectionParams params{\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.103.cpp\nindex eb9c349c22..83b7af4d06 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.103.cpp\n@@ -415,7 +415,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         add_coin(1 * CENT + input_fee, 2, expected_result);\n         coin_control.m_allow_other_inputs = true;\n         COutput select_coin = available_coins.All().at(1); // pre select 9 coin\n-        coin_control.Select(select_coin.outpoint);\n+        \n         PreSelectedInputs selected_input;\n         selected_input.Insert(select_coin, coin_selection_params_bnb.m_subtract_fee_outputs);\n         available_coins.Erase({(++available_coins.coins[OutputType::BECH32].begin())->outpoint});\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.261.cpp\nindex eb9c349c22..b6f95ff8c9 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.261.cpp\n@@ -1399,7 +1399,7 @@ static util::Result<SelectionResult> select_coins(const CAmount& target, const C\n     std::unique_ptr<CWallet> wallet = NewWallet(m_node);\n     auto available_coins = coin_setup(*wallet);\n \n-    LOCK(wallet->cs_wallet);\n+    \n     auto result = SelectCoins(*wallet, available_coins, /*pre_set_inputs=*/ {}, target, cc, cs_params);\n     if (result) {\n         const auto signedTxSize = 10 + 34 + 68 * result->GetInputSet().size(); // static header size + output size + inputs size (P2WPKH)\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.73.cpp\nindex eb9c349c22..785fc529c7 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.73.cpp\n@@ -354,7 +354,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         coin_control.Select(select_coin.outpoint);\n         PreSelectedInputs selected_input;\n         selected_input.Insert(select_coin, coin_selection_params_bnb.m_subtract_fee_outputs);\n-        available_coins.Erase({available_coins.coins[OutputType::BECH32].begin()->outpoint});\n+        \n \n         LOCK(wallet->cs_wallet);\n         const auto result10 = SelectCoins(*wallet, available_coins, selected_input, 10 * CENT, coin_control, coin_selection_params_bnb);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.71.cpp\nindex eb9c349c22..ee610cede8 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.71.cpp\n@@ -351,7 +351,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         CCoinControl coin_control;\n         coin_control.m_allow_other_inputs = true;\n         COutput select_coin = available_coins.All().at(0);\n-        coin_control.Select(select_coin.outpoint);\n+        \n         PreSelectedInputs selected_input;\n         selected_input.Insert(select_coin, coin_selection_params_bnb.m_subtract_fee_outputs);\n         available_coins.Erase({available_coins.coins[OutputType::BECH32].begin()->outpoint});\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.59.cpp\nindex eb9c349c22..f9a8026e34 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.59.cpp\n@@ -298,7 +298,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     // Select 1 Cent with pool of only greater than 5 Cent\n     utxo_pool.clear();\n     for (int i = 5; i <= 20; ++i) {\n-        add_coin(i * CENT, i, utxo_pool);\n+        \n     }\n     // Run 100 times, to make sure it is never finding a solution\n     for (int i = 0; i < 100; ++i) {\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.58.cpp\nindex eb9c349c22..65b31a8cdf 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.58.cpp\n@@ -296,7 +296,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     // Behavior tests //\n     ////////////////////\n     // Select 1 Cent with pool of only greater than 5 Cent\n-    utxo_pool.clear();\n+    \n     for (int i = 5; i <= 20; ++i) {\n         add_coin(i * CENT, i, utxo_pool);\n     }\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.262.cpp\nindex eb9c349c22..be2adbf34c 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.262.cpp\n@@ -1446,7 +1446,7 @@ BOOST_AUTO_TEST_CASE(check_max_selection_weight)\n             target, cs_params, cc, [&](CWallet& wallet) {\n                 CoinsResult available_coins;\n                 for (int j = 0; j < 1515; ++j) {\n-                    add_coin(available_coins, wallet, CAmount(0.033 * COIN), CFeeRate(0), 144, false, 0, true);\n+                    \n                 }\n \n                 add_coin(available_coins, wallet, CAmount(50 * COIN), CFeeRate(0), 144, false, 0, true);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.64.cpp\nindex eb9c349c22..ccf3249f1b 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.64.cpp\n@@ -331,7 +331,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         BOOST_CHECK(!SelectCoinsBnB(GroupCoins(available_coins.All()), 1 * CENT, coin_selection_params_bnb.m_cost_of_change));\n \n         // Test fees subtracted from output:\n-        available_coins.Clear();\n+        \n         add_coin(available_coins, *wallet, 1 * CENT, coin_selection_params_bnb.m_effective_feerate);\n         available_coins.All().at(0).input_bytes = 40;\n         const auto result9 = SelectCoinsBnB(GroupCoins(available_coins.All()), 1 * CENT, coin_selection_params_bnb.m_cost_of_change);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.266.cpp\nindex eb9c349c22..d39fb3f05b 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.266.cpp\n@@ -1497,7 +1497,7 @@ BOOST_AUTO_TEST_CASE(check_max_selection_weight)\n             target, cs_params, cc, [&](CWallet& wallet) {\n                 CoinsResult available_coins;\n                 for (int j = 0; j < 1515; ++j) {\n-                    add_coin(available_coins, wallet, CAmount(0.033 * COIN), CFeeRate(0), 144, false, 0, true);\n+                    \n                 }\n                 return available_coins;\n             },\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.74.cpp\nindex eb9c349c22..b528ded86c 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.74.cpp\n@@ -356,7 +356,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         selected_input.Insert(select_coin, coin_selection_params_bnb.m_subtract_fee_outputs);\n         available_coins.Erase({available_coins.coins[OutputType::BECH32].begin()->outpoint});\n \n-        LOCK(wallet->cs_wallet);\n+        \n         const auto result10 = SelectCoins(*wallet, available_coins, selected_input, 10 * CENT, coin_control, coin_selection_params_bnb);\n         BOOST_CHECK(result10);\n     }\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.60.cpp\nindex eb9c349c22..153c3b9101 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.60.cpp\n@@ -317,7 +317,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         /*tx_noinputs_size=*/ 0,\n         /*avoid_partial=*/ false,\n     };\n-    coin_selection_params_bnb.m_change_fee = coin_selection_params_bnb.m_effective_feerate.GetFee(coin_selection_params_bnb.change_output_size);\n+    \n     coin_selection_params_bnb.m_cost_of_change = coin_selection_params_bnb.m_effective_feerate.GetFee(coin_selection_params_bnb.change_spend_size) + coin_selection_params_bnb.m_change_fee;\n     coin_selection_params_bnb.min_viable_change = coin_selection_params_bnb.m_effective_feerate.GetFee(coin_selection_params_bnb.change_spend_size);\n \n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.139.cpp\nindex eb9c349c22..86e1ace1c9 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.139.cpp\n@@ -618,7 +618,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         // check that the smallest bigger coin is used\n         add_coin(available_coins, *wallet,  1*COIN);\n         add_coin(available_coins, *wallet,  2*COIN);\n-        add_coin(available_coins, *wallet,  3*COIN);\n+        \n         add_coin(available_coins, *wallet,  4*COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n         const auto result14 = KnapsackSolver(KnapsackGroupOutputs(available_coins, *wallet, filter_confirmed), 95 * CENT, CENT);\n         BOOST_CHECK(result14);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.105.cpp\nindex eb9c349c22..ba8ce3c41f 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.105.cpp\n@@ -418,7 +418,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         coin_control.Select(select_coin.outpoint);\n         PreSelectedInputs selected_input;\n         selected_input.Insert(select_coin, coin_selection_params_bnb.m_subtract_fee_outputs);\n-        available_coins.Erase({(++available_coins.coins[OutputType::BECH32].begin())->outpoint});\n+        \n         const auto result13 = SelectCoins(*wallet, available_coins, selected_input, 10 * CENT, coin_control, coin_selection_params_bnb);\n         BOOST_CHECK(EquivalentResult(expected_result, *result13));\n     }\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.111.cpp\nindex eb9c349c22..f9a7a85634 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.111.cpp\n@@ -435,7 +435,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         add_coin(available_coins, *wallet, 8 * CENT, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n         add_coin(available_coins, *wallet, 5 * CENT, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true, /*custom_size=*/MAX_STANDARD_TX_WEIGHT);\n         add_coin(available_coins, *wallet, 3 * CENT, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n-        add_coin(available_coins, *wallet, 1 * CENT, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n+        \n \n         CAmount selection_target = 16 * CENT;\n         const auto& no_res = SelectCoinsBnB(GroupCoins(available_coins.All(), /*subtract_fee_outputs*/true),\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.61.cpp\nindex eb9c349c22..d957901e0d 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.61.cpp\n@@ -318,7 +318,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         /*avoid_partial=*/ false,\n     };\n     coin_selection_params_bnb.m_change_fee = coin_selection_params_bnb.m_effective_feerate.GetFee(coin_selection_params_bnb.change_output_size);\n-    coin_selection_params_bnb.m_cost_of_change = coin_selection_params_bnb.m_effective_feerate.GetFee(coin_selection_params_bnb.change_spend_size) + coin_selection_params_bnb.m_change_fee;\n+    \n     coin_selection_params_bnb.min_viable_change = coin_selection_params_bnb.m_effective_feerate.GetFee(coin_selection_params_bnb.change_spend_size);\n \n     {\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.75.cpp\nindex eb9c349c22..2b7c8a12cf 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.75.cpp\n@@ -362,7 +362,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     }\n     {\n         std::unique_ptr<CWallet> wallet = NewWallet(m_node);\n-        LOCK(wallet->cs_wallet); // Every 'SelectCoins' call requires it\n+        \n \n         CoinsResult available_coins;\n \n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.271.cpp\nindex eb9c349c22..ad6e043f93 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.271.cpp\n@@ -1546,7 +1546,7 @@ BOOST_AUTO_TEST_CASE(SelectCoins_effective_value_test)\n \n     LOCK(wallet->cs_wallet);\n     const auto preset_inputs = *Assert(FetchSelectedInputs(*wallet, cc, cs_params));\n-    available_coins.Erase({available_coins.coins[OutputType::BECH32].begin()->outpoint});\n+    \n \n     const auto result = SelectCoins(*wallet, available_coins, preset_inputs, target, cc, cs_params);\n     BOOST_CHECK(!result);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.77.cpp\nindex eb9c349c22..e191c26d95 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.77.cpp\n@@ -368,7 +368,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n \n         // single coin should be selected when effective fee > long term fee\n         coin_selection_params_bnb.m_effective_feerate = CFeeRate(5000);\n-        coin_selection_params_bnb.m_long_term_feerate = CFeeRate(3000);\n+        \n \n         // Add selectable outputs, increasing their raw amounts by their input fee to make the effective value equal to the raw amount\n         CAmount input_fee = coin_selection_params_bnb.m_effective_feerate.GetFee(/*num_bytes=*/68); // bech32 input size (default test output type)\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.107.cpp\nindex eb9c349c22..cb7666df35 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.107.cpp\n@@ -431,7 +431,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n \n         CoinsResult available_coins;\n         add_coin(available_coins, *wallet, 10 * CENT, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n-        add_coin(available_coins, *wallet, 9 * CENT, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n+        \n         add_coin(available_coins, *wallet, 8 * CENT, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n         add_coin(available_coins, *wallet, 5 * CENT, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true, /*custom_size=*/MAX_STANDARD_TX_WEIGHT);\n         add_coin(available_coins, *wallet, 3 * CENT, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.106.cpp\nindex eb9c349c22..433247f876 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.106.cpp\n@@ -430,7 +430,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         std::unique_ptr<CWallet> wallet = NewWallet(m_node);\n \n         CoinsResult available_coins;\n-        add_coin(available_coins, *wallet, 10 * CENT, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n+        \n         add_coin(available_coins, *wallet, 9 * CENT, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n         add_coin(available_coins, *wallet, 8 * CENT, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true);\n         add_coin(available_coins, *wallet, 5 * CENT, coin_selection_params_bnb.m_effective_feerate, 6 * 24, false, 0, true, /*custom_size=*/MAX_STANDARD_TX_WEIGHT);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.62.cpp\nindex eb9c349c22..2b78b02fa6 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.62.cpp\n@@ -319,7 +319,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     };\n     coin_selection_params_bnb.m_change_fee = coin_selection_params_bnb.m_effective_feerate.GetFee(coin_selection_params_bnb.change_output_size);\n     coin_selection_params_bnb.m_cost_of_change = coin_selection_params_bnb.m_effective_feerate.GetFee(coin_selection_params_bnb.change_spend_size) + coin_selection_params_bnb.m_change_fee;\n-    coin_selection_params_bnb.min_viable_change = coin_selection_params_bnb.m_effective_feerate.GetFee(coin_selection_params_bnb.change_spend_size);\n+    \n \n     {\n         std::unique_ptr<CWallet> wallet = NewWallet(m_node);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.270.cpp\nindex eb9c349c22..7d060e40ad 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.270.cpp\n@@ -1544,7 +1544,7 @@ BOOST_AUTO_TEST_CASE(SelectCoins_effective_value_test)\n     cc.SetInputWeight(output.outpoint, 148);\n     cc.Select(output.outpoint).SetTxOut(output.txout);\n \n-    LOCK(wallet->cs_wallet);\n+    \n     const auto preset_inputs = *Assert(FetchSelectedInputs(*wallet, cc, cs_params));\n     available_coins.Erase({available_coins.coins[OutputType::BECH32].begin()->outpoint});\n \n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.149.cpp\nindex eb9c349c22..35fec141f9 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.149.cpp\n@@ -655,7 +655,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n \n         // if we add more small coins:\n         add_coin(available_coins, *wallet, CENT * 6 / 10);\n-        add_coin(available_coins, *wallet, CENT * 7 / 10);\n+        \n \n         // and try again to make 1.0 * CENT\n         const auto result18 = KnapsackSolver(KnapsackGroupOutputs(available_coins, *wallet, filter_confirmed), 1 * CENT, CENT);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.161.cpp\nindex eb9c349c22..eee81450fe 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.161.cpp\n@@ -692,7 +692,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(available_coins, *wallet, CENT * 4 / 10);\n         add_coin(available_coins, *wallet, CENT * 6 / 10);\n         add_coin(available_coins, *wallet, CENT * 8 / 10);\n-        add_coin(available_coins, *wallet, 1111 * CENT);\n+        \n         const auto result21 = KnapsackSolver(KnapsackGroupOutputs(available_coins, *wallet, filter_confirmed), CENT, CENT);\n         BOOST_CHECK(result21);\n         BOOST_CHECK_EQUAL(result21->GetSelectedValue(), CENT);   // we should get the exact amount\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.174.cpp\nindex eb9c349c22..3a4752cda5 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.174.cpp\n@@ -783,7 +783,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(available_coins, *wallet, 10 * CENT);\n         add_coin(available_coins, *wallet, 15 * CENT);\n         add_coin(available_coins, *wallet, 20 * CENT);\n-        add_coin(available_coins, *wallet, 25 * CENT);\n+        \n \n         for (int i = 0; i < RUN_TESTS; i++) {\n             int fails = 0;\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.160.cpp\nindex eb9c349c22..106f097634 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.160.cpp\n@@ -691,7 +691,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         available_coins.Clear();\n         add_coin(available_coins, *wallet, CENT * 4 / 10);\n         add_coin(available_coins, *wallet, CENT * 6 / 10);\n-        add_coin(available_coins, *wallet, CENT * 8 / 10);\n+        \n         add_coin(available_coins, *wallet, 1111 * CENT);\n         const auto result21 = KnapsackSolver(KnapsackGroupOutputs(available_coins, *wallet, filter_confirmed), CENT, CENT);\n         BOOST_CHECK(result21);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.148.cpp\nindex eb9c349c22..85ece46406 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.148.cpp\n@@ -654,7 +654,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         BOOST_CHECK_EQUAL(result17->GetSelectedValue(), 1 * CENT); // we should get the exact amount\n \n         // if we add more small coins:\n-        add_coin(available_coins, *wallet, CENT * 6 / 10);\n+        \n         add_coin(available_coins, *wallet, CENT * 7 / 10);\n \n         // and try again to make 1.0 * CENT\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.202.cpp\nindex eb9c349c22..4539447981 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.202.cpp\n@@ -1045,7 +1045,7 @@ BOOST_AUTO_TEST_CASE(bump_fee_test)\n         const std::vector<std::shared_ptr<COutput>> inputs = selection.GetShuffledInputVector();\n \n         for (size_t i = 0; i < inputs.size(); ++i) {\n-            inputs[i]->ApplyBumpFee(20*(i+1));\n+            \n         }\n \n         selection.RecalculateWaste(min_viable_change, change_cost, change_fee);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.38.cpp\nindex eb9c349c22..08baf47ac5 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.38.cpp\n@@ -250,7 +250,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     expected_result.Clear();\n \n     // Select 10 Cent\n-    add_coin(5 * CENT, 5, utxo_pool);\n+    \n     add_coin(4 * CENT, 4, expected_result);\n     add_coin(3 * CENT, 3, expected_result);\n     add_coin(2 * CENT, 2, expected_result);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.214.cpp\nindex eb9c349c22..10612a5512 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.214.cpp\n@@ -1139,7 +1139,7 @@ BOOST_AUTO_TEST_CASE(coin_grinder_tests)\n         const auto& res = CoinGrinder(target, dummy_params, m_node, max_selection_weight, [&](CWallet& wallet) {\n             CoinsResult available_coins;\n             for (int j = 0; j < 10; ++j) {\n-                add_coin(available_coins, wallet, CAmount(1 * COIN));\n+                \n                 add_coin(available_coins, wallet, CAmount(2 * COIN));\n             }\n             return available_coins;\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.177.cpp\nindex eb9c349c22..1f4935e658 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.177.cpp\n@@ -823,7 +823,7 @@ BOOST_AUTO_TEST_CASE(ApproximateBestSubset)\n BOOST_AUTO_TEST_CASE(SelectCoins_test)\n {\n     std::unique_ptr<CWallet> wallet = NewWallet(m_node);\n-    LOCK(wallet->cs_wallet); // Every 'SelectCoins' call requires it\n+    \n \n     // Random generator stuff\n     std::default_random_engine generator;\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.215.cpp\nindex eb9c349c22..2b0ae4569b 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.215.cpp\n@@ -1140,7 +1140,7 @@ BOOST_AUTO_TEST_CASE(coin_grinder_tests)\n             CoinsResult available_coins;\n             for (int j = 0; j < 10; ++j) {\n                 add_coin(available_coins, wallet, CAmount(1 * COIN));\n-                add_coin(available_coins, wallet, CAmount(2 * COIN));\n+                \n             }\n             return available_coins;\n         });\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.205.cpp\nindex eb9c349c22..d2784c98aa 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.205.cpp\n@@ -1053,7 +1053,7 @@ BOOST_AUTO_TEST_CASE(bump_fee_test)\n         BOOST_CHECK_EQUAL(expected_waste, selection.GetWaste());\n \n         selection.SetBumpFeeDiscount(30);\n-        selection.RecalculateWaste(min_viable_change, change_cost, change_fee);\n+        \n         expected_waste = fee_diff * -2 + /*bump_fees=*/60 - /*group_discount=*/30 + /*excess = 100 - bump_fees + group_discount*/70;\n         BOOST_CHECK_EQUAL(expected_waste, selection.GetWaste());\n     }\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.173.cpp\nindex eb9c349c22..f176b7c59a 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.173.cpp\n@@ -782,7 +782,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(available_coins, *wallet, 5 * CENT);\n         add_coin(available_coins, *wallet, 10 * CENT);\n         add_coin(available_coins, *wallet, 15 * CENT);\n-        add_coin(available_coins, *wallet, 20 * CENT);\n+        \n         add_coin(available_coins, *wallet, 25 * CENT);\n \n         for (int i = 0; i < RUN_TESTS; i++) {\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.172.cpp\nindex eb9c349c22..aac05a667e 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.172.cpp\n@@ -781,7 +781,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         // one of which should be picked at random\n         add_coin(available_coins, *wallet, 5 * CENT);\n         add_coin(available_coins, *wallet, 10 * CENT);\n-        add_coin(available_coins, *wallet, 15 * CENT);\n+        \n         add_coin(available_coins, *wallet, 20 * CENT);\n         add_coin(available_coins, *wallet, 25 * CENT);\n \n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.204.cpp\nindex eb9c349c22..f1eb73e042 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.204.cpp\n@@ -1052,7 +1052,7 @@ BOOST_AUTO_TEST_CASE(bump_fee_test)\n         CAmount expected_waste = fee_diff * -2 + /*bump_fees=*/60 + /*excess = 100 - bump_fees*/40;\n         BOOST_CHECK_EQUAL(expected_waste, selection.GetWaste());\n \n-        selection.SetBumpFeeDiscount(30);\n+        \n         selection.RecalculateWaste(min_viable_change, change_cost, change_fee);\n         expected_waste = fee_diff * -2 + /*bump_fees=*/60 - /*group_discount=*/30 + /*excess = 100 - bump_fees + group_discount*/70;\n         BOOST_CHECK_EQUAL(expected_waste, selection.GetWaste());\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.14.cpp\nindex eb9c349c22..612385a2c1 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.14.cpp\n@@ -135,7 +135,7 @@ static bool EqualResult(const SelectionResult& a, const SelectionResult& b)\n \n static CAmount make_hard_case(int utxos, std::vector<COutput>& utxo_pool)\n {\n-    utxo_pool.clear();\n+    \n     CAmount target = 0;\n     for (int i = 0; i < utxos; ++i) {\n         target += CAmount{1} << (utxos+i);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.170.cpp\nindex eb9c349c22..72d047f003 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.170.cpp\n@@ -779,7 +779,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         // add 75 cents in small change.  not enough to make 90 cents,\n         // then try making 90 cents.  there are multiple competing \"smallest bigger\" coins,\n         // one of which should be picked at random\n-        add_coin(available_coins, *wallet, 5 * CENT);\n+        \n         add_coin(available_coins, *wallet, 10 * CENT);\n         add_coin(available_coins, *wallet, 15 * CENT);\n         add_coin(available_coins, *wallet, 20 * CENT);\n",
            "diff --git a/src/wallet/test/coinselector_tests.cpp b/muts/coinselector_tests.mutant.171.cpp\nindex eb9c349c22..ccabf12ef0 100644\n--- a/src/wallet/test/coinselector_tests.cpp\n+++ b/muts/coinselector_tests.mutant.171.cpp\n@@ -780,7 +780,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         // then try making 90 cents.  there are multiple competing \"smallest bigger\" coins,\n         // one of which should be picked at random\n         add_coin(available_coins, *wallet, 5 * CENT);\n-        add_coin(available_coins, *wallet, 10 * CENT);\n+        \n         add_coin(available_coins, *wallet, 15 * CENT);\n         add_coin(available_coins, *wallet, 20 * CENT);\n         add_coin(available_coins, *wallet, 25 * CENT);\n"
        ]
    },
    {
        "filename": "src/wallet/test/coinselection_tests.cpp",
        "head": "639a0dd520d747a189a9d874d2a2888fb8b553f2",
        "mutation_score": 0.77,
        "diffs": [
            "diff --git a/src/wallet/test/coinselection_tests.cpp b/muts/coinselection_tests.mutant.0.cpp\nindex bb6a65e6cc..2f0babc035 100644\n--- a/src/wallet/test/coinselection_tests.cpp\n+++ b/muts/coinselection_tests.mutant.0.cpp\n@@ -30,7 +30,7 @@ static CoinSelectionParams init_default_params()\n         /*tx_noinputs_size=*/11 + 31, //static header size + output size\n         /*avoid_partial=*/false,\n     };\n-    dcsp.m_change_fee = /*155 sats=*/dcsp.m_effective_feerate.GetFee(dcsp.change_output_size);\n+    \n     dcsp.m_cost_of_change = /*204 + 155 sats=*/dcsp.m_discard_feerate.GetFee(dcsp.change_spend_size) + dcsp.m_change_fee;\n     dcsp.min_viable_change = /*204 sats=*/dcsp.m_discard_feerate.GetFee(dcsp.change_spend_size);\n     dcsp.m_subtract_fee_outputs = false;\n",
            "diff --git a/src/wallet/test/coinselection_tests.cpp b/muts/coinselection_tests.mutant.2.cpp\nindex bb6a65e6cc..9185550e9b 100644\n--- a/src/wallet/test/coinselection_tests.cpp\n+++ b/muts/coinselection_tests.mutant.2.cpp\n@@ -32,7 +32,7 @@ static CoinSelectionParams init_default_params()\n     };\n     dcsp.m_change_fee = /*155 sats=*/dcsp.m_effective_feerate.GetFee(dcsp.change_output_size);\n     dcsp.m_cost_of_change = /*204 + 155 sats=*/dcsp.m_discard_feerate.GetFee(dcsp.change_spend_size) + dcsp.m_change_fee;\n-    dcsp.min_viable_change = /*204 sats=*/dcsp.m_discard_feerate.GetFee(dcsp.change_spend_size);\n+    \n     dcsp.m_subtract_fee_outputs = false;\n     return dcsp;\n }\n",
            "diff --git a/src/wallet/test/coinselection_tests.cpp b/muts/coinselection_tests.mutant.7.cpp\nindex bb6a65e6cc..0fc9de737c 100644\n--- a/src/wallet/test/coinselection_tests.cpp\n+++ b/muts/coinselection_tests.mutant.7.cpp\n@@ -64,7 +64,7 @@ static void AddCoins(std::vector<OutputGroup>& utxo_pool, std::vector<CAmount> c\n /** Make multiple coins that share the same effective value */\n static void AddDuplicateCoins(std::vector<OutputGroup>& utxo_pool, int count, int amount) {\n     for (int i = 0 ; i < count; ++i) {\n-        utxo_pool.push_back(MakeCoin(amount));\n+        \n     }\n }\n \n",
            "diff --git a/src/wallet/test/coinselection_tests.cpp b/muts/coinselection_tests.mutant.6.cpp\nindex bb6a65e6cc..b3e0f35494 100644\n--- a/src/wallet/test/coinselection_tests.cpp\n+++ b/muts/coinselection_tests.mutant.6.cpp\n@@ -57,7 +57,7 @@ static OutputGroup MakeCoin(const CAmount& amount, bool is_eff_value = true, Coi\n static void AddCoins(std::vector<OutputGroup>& utxo_pool, std::vector<CAmount> coins, CoinSelectionParams cs_params = default_cs_params)\n {\n     for (CAmount c : coins) {\n-        utxo_pool.push_back(MakeCoin(c, true, cs_params));\n+        \n     }\n }\n \n",
            "diff --git a/src/wallet/test/coinselection_tests.cpp b/muts/coinselection_tests.mutant.10.cpp\nindex bb6a65e6cc..1a5e4ae172 100644\n--- a/src/wallet/test/coinselection_tests.cpp\n+++ b/muts/coinselection_tests.mutant.10.cpp\n@@ -80,7 +80,7 @@ static bool EquivalentResult(const SelectionResult& a, const SelectionResult& b)\n     for (const auto& coin : b.GetInputSet()) {\n         b_amts.push_back(coin->txout.nValue);\n     }\n-    std::sort(a_amts.begin(), a_amts.end());\n+    \n     std::sort(b_amts.begin(), b_amts.end());\n \n     std::pair<std::vector<CAmount>::iterator, std::vector<CAmount>::iterator> ret = std::mismatch(a_amts.begin(), a_amts.end(), b_amts.begin());\n",
            "diff --git a/src/wallet/test/coinselection_tests.cpp b/muts/coinselection_tests.mutant.16.cpp\nindex bb6a65e6cc..3dd94838a4 100644\n--- a/src/wallet/test/coinselection_tests.cpp\n+++ b/muts/coinselection_tests.mutant.16.cpp\n@@ -138,7 +138,7 @@ BOOST_AUTO_TEST_CASE(bnb_test)\n     // Test skipping of equivalent input sets\n     std::vector<OutputGroup> clone_pool;\n     AddCoins(clone_pool, {2 * CENT, 7 * CENT, 7 * CENT});\n-    AddDuplicateCoins(clone_pool, 50'000, 5 * CENT);\n+    \n     TestBnBSuccess(\"Skip equivalent input sets\", clone_pool, /*selection_target=*/16 * CENT, /*expected_input_amounts=*/{2 * CENT, 7 * CENT, 7 * CENT});\n \n     // Test BnB attempt limit\n"
        ]
    }
]