[
  {
    "filename": "src/wallet/coinselection.cpp",
    "diffs": [
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.14.cpp\nindex cee558088f..947bf7b642 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.14.cpp\n@@ -118,7 +118,7 @@ util::Result<SelectionResult> SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool\n     CAmount best_waste = MAX_MONEY;\n \n     bool is_feerate_high = utxo_pool.at(0).fee > utxo_pool.at(0).long_term_fee;\n-    bool max_tx_weight_exceeded = false;\n+        bool max_tx_weight_exceeded = true;\n \n     // Depth First search loop for choosing the UTXOs\n     for (size_t curr_try = 0, utxo_pool_index = 0; curr_try < TOTAL_TRIES; ++curr_try, ++utxo_pool_index) {\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.17.cpp\nindex cee558088f..b99220fd05 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.17.cpp\n@@ -121,7 +121,7 @@ util::Result<SelectionResult> SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool\n     bool max_tx_weight_exceeded = false;\n \n     // Depth First search loop for choosing the UTXOs\n-    for (size_t curr_try = 0, utxo_pool_index = 0; curr_try < TOTAL_TRIES; ++curr_try, ++utxo_pool_index) {\n+        for (size_t curr_try = 0, utxo_pool_index = 0; curr_try <= TOTAL_TRIES; ++curr_try, ++utxo_pool_index) {\n         // Conditions for starting a backtrack\n         bool backtrack = false;\n         if (curr_value + curr_available_value < selection_target || // Cannot possibly reach target with the amount remaining in the curr_available_value.\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.12.cpp\nindex cee558088f..a10f510bb3 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.12.cpp\n@@ -117,7 +117,7 @@ util::Result<SelectionResult> SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool\n     std::vector<size_t> best_selection;\n     CAmount best_waste = MAX_MONEY;\n \n-    bool is_feerate_high = utxo_pool.at(0).fee > utxo_pool.at(0).long_term_fee;\n+        bool is_feerate_high = utxo_pool.at(0).fee >= utxo_pool.at(0).long_term_fee;\n     bool max_tx_weight_exceeded = false;\n \n     // Depth First search loop for choosing the UTXOs\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.37.cpp\nindex cee558088f..9747cd26c9 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.37.cpp\n@@ -128,7 +128,7 @@ util::Result<SelectionResult> SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool\n             curr_value > selection_target + cost_of_change || // Selected value is out of range, go back and try other branch\n             (curr_waste > best_waste && is_feerate_high)) { // Don't select things which we know will be more wasteful if the waste is increasing\n             backtrack = true;\n-        } else if (curr_selection_weight > max_selection_weight) { // Selected UTXOs weight exceeds the maximum weight allowed, cannot find more solutions by adding more inputs\n+                } else if (curr_selection_weight >= max_selection_weight) { // Selected UTXOs weight exceeds the maximum weight allowed, cannot find more solutions by adding more inputs\n             max_tx_weight_exceeded = true; // at least one selection attempt exceeded the max weight\n             backtrack = true;\n         } else if (curr_value >= selection_target) {       // Selected value is within range\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.28.cpp\nindex cee558088f..04f4c0d4e3 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.28.cpp\n@@ -432,7 +432,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n \n         // EVALUATE current selection: check for solutions and see whether we can CUT or SHIFT before EXPLORING further\n         auto curr_tail = curr_selection.back();\n-        if (curr_amount + lookahead[curr_tail] < total_target) {\n+                if (curr_amount + lookahead[curr_tail] <= total_target) {\n             // Insufficient funds with lookahead: CUT\n             should_cut = true;\n         } else if (curr_weight > best_selection_weight) {\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.17.cpp\nindex cee558088f..77a311485b 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.17.cpp\n@@ -354,7 +354,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n     std::vector<size_t> best_selection;\n \n     // The currently selected effective amount, and the effective amount of the best selection so far\n-    CAmount curr_amount = 0;\n+        CAmount curr_amount = 0 - 1;\n     CAmount best_selection_amount = MAX_MONEY;\n \n     // The weight of the currently selected input set, and the weight of the best selection\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.16.cpp\nindex cee558088f..511d5d6d77 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.16.cpp\n@@ -354,7 +354,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n     std::vector<size_t> best_selection;\n \n     // The currently selected effective amount, and the effective amount of the best selection so far\n-    CAmount curr_amount = 0;\n+        CAmount curr_amount = 0 + 1;\n     CAmount best_selection_amount = MAX_MONEY;\n \n     // The weight of the currently selected input set, and the weight of the best selection\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.13.cpp\nindex cee558088f..1af30f6a6b 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.13.cpp\n@@ -344,7 +344,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n     }\n \n     const CAmount total_target = selection_target + change_target;\n-    if (total_available < total_target) {\n+        if (total_available <= total_target) {\n         // Insufficient funds\n         return util::Error();\n     }\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.39.cpp\nindex cee558088f..2553c533a5 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.39.cpp\n@@ -441,7 +441,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n             // Worse weight than best solution. More UTXOs only increase weight:\n             // CUT if last selected group had minimal weight, else SHIFT\n             if (utxo_pool[curr_tail].m_weight <= min_tail_weight[curr_tail]) {\n-                should_cut = true;\n+                                should_cut = false;\n             } else {\n                 should_shift  = true;\n             }\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.60.cpp\nindex cee558088f..2ba824a28a 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.60.cpp\n@@ -463,7 +463,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n             }\n         }\n \n-        if (curr_try >= TOTAL_TRIES) {\n+                if (curr_try > TOTAL_TRIES) {\n             // Solution is not guaranteed to be optimal if `curr_try` hit TOTAL_TRIES\n             result.SetAlgoCompleted(false);\n             break;\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.61.cpp\nindex cee558088f..a25666a59c 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.61.cpp\n@@ -465,7 +465,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n \n         if (curr_try >= TOTAL_TRIES) {\n             // Solution is not guaranteed to be optimal if `curr_try` hit TOTAL_TRIES\n-            result.SetAlgoCompleted(false);\n+                        result.SetAlgoCompleted(true);\n             break;\n         }\n \n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.64.cpp\nindex cee558088f..e1a5ea2e30 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.64.cpp\n@@ -478,7 +478,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n             // Neither adding to the current selection nor exploring the omission branch of the last selected UTXO can\n             // find any solutions. Redirect to exploring the Omission branch of the penultimate selected UTXO (i.e.\n             // set `next_utxo` to one after the penultimate selected, then deselect the last two selected UTXOs)\n-            should_cut = false;\n+                        should_cut = true;\n             deselect_last();\n             should_shift  = true;\n         }\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.42.cpp\nindex cee558088f..5a653ea095 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.42.cpp\n@@ -445,7 +445,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n             } else {\n                 should_shift  = true;\n             }\n-        } else if (curr_amount >= total_target) {\n+                } else if (curr_amount > total_target) {\n             // Success, adding more weight cannot be better: SHIFT\n             should_shift  = true;\n             if (curr_weight < best_selection_weight || (curr_weight == best_selection_weight && curr_amount < best_selection_amount)) {\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.68.cpp\nindex cee558088f..f0745f97a4 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.68.cpp\n@@ -488,7 +488,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n             if (curr_selection.empty()) {\n                 // Exhausted search space before running into attempt limit\n                 is_done = true;\n-                result.SetAlgoCompleted(true);\n+                                result.SetAlgoCompleted(false);\n                 break;\n             }\n             next_utxo = curr_selection.back() + 1;\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.0.cpp\nindex cee558088f..4b768d2bd9 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.0.cpp\n@@ -331,7 +331,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n     std::vector<int> min_tail_weight(utxo_pool.size());\n \n     // Calculate lookahead values, min_tail_weights, and check that there are sufficient funds\n-    CAmount total_available = 0;\n+        CAmount total_available = 0 + 1;\n     int min_group_weight = std::numeric_limits<int>::max();\n     for (size_t i = 0; i < utxo_pool.size(); ++i) {\n         size_t index = utxo_pool.size() - 1 - i; // Loop over every element in reverse order\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.1.cpp\nindex cee558088f..c16b20360c 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.1.cpp\n@@ -331,7 +331,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n     std::vector<int> min_tail_weight(utxo_pool.size());\n \n     // Calculate lookahead values, min_tail_weights, and check that there are sufficient funds\n-    CAmount total_available = 0;\n+        CAmount total_available = 0 - 1;\n     int min_group_weight = std::numeric_limits<int>::max();\n     for (size_t i = 0; i < utxo_pool.size(); ++i) {\n         size_t index = utxo_pool.size() - 1 - i; // Loop over every element in reverse order\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.37.cpp\nindex cee558088f..b3d32e6c02 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.37.cpp\n@@ -437,7 +437,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n             should_cut = true;\n         } else if (curr_weight > best_selection_weight) {\n             // best_selection_weight is initialized to max_selection_weight\n-            if (curr_weight > max_selection_weight) max_tx_weight_exceeded = true;\n+                        if (curr_weight >= max_selection_weight) max_tx_weight_exceeded = true;\n             // Worse weight than best solution. More UTXOs only increase weight:\n             // CUT if last selected group had minimal weight, else SHIFT\n             if (utxo_pool[curr_tail].m_weight <= min_tail_weight[curr_tail]) {\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.18.cpp\nindex cee558088f..38a41a6de5 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.18.cpp\n@@ -362,7 +362,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n     int best_selection_weight = max_selection_weight; // Tie is fine, because we prefer lower selection amount\n \n     // Whether the input sets generated during this search have exceeded the maximum transaction weight at any point\n-    bool max_tx_weight_exceeded = false;\n+        bool max_tx_weight_exceeded = true;\n \n     // Index of the next UTXO to consider in utxo_pool\n     size_t next_utxo = 0;\n"
    ]
  }
]