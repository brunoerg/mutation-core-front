[
  {
    "filename": "src/wallet/coinselection.cpp",
    "diffs": [
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.14.cpp\nindex cee558088f..947bf7b642 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.14.cpp\n@@ -118,7 +118,7 @@ util::Result<SelectionResult> SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool\n     CAmount best_waste = MAX_MONEY;\n \n     bool is_feerate_high = utxo_pool.at(0).fee > utxo_pool.at(0).long_term_fee;\n-    bool max_tx_weight_exceeded = false;\n+        bool max_tx_weight_exceeded = true;\n \n     // Depth First search loop for choosing the UTXOs\n     for (size_t curr_try = 0, utxo_pool_index = 0; curr_try < TOTAL_TRIES; ++curr_try, ++utxo_pool_index) {\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.17.cpp\nindex cee558088f..b99220fd05 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.17.cpp\n@@ -121,7 +121,7 @@ util::Result<SelectionResult> SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool\n     bool max_tx_weight_exceeded = false;\n \n     // Depth First search loop for choosing the UTXOs\n-    for (size_t curr_try = 0, utxo_pool_index = 0; curr_try < TOTAL_TRIES; ++curr_try, ++utxo_pool_index) {\n+        for (size_t curr_try = 0, utxo_pool_index = 0; curr_try <= TOTAL_TRIES; ++curr_try, ++utxo_pool_index) {\n         // Conditions for starting a backtrack\n         bool backtrack = false;\n         if (curr_value + curr_available_value < selection_target || // Cannot possibly reach target with the amount remaining in the curr_available_value.\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.12.cpp\nindex cee558088f..a10f510bb3 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.12.cpp\n@@ -117,7 +117,7 @@ util::Result<SelectionResult> SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool\n     std::vector<size_t> best_selection;\n     CAmount best_waste = MAX_MONEY;\n \n-    bool is_feerate_high = utxo_pool.at(0).fee > utxo_pool.at(0).long_term_fee;\n+        bool is_feerate_high = utxo_pool.at(0).fee >= utxo_pool.at(0).long_term_fee;\n     bool max_tx_weight_exceeded = false;\n \n     // Depth First search loop for choosing the UTXOs\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.37.cpp\nindex cee558088f..9747cd26c9 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.37.cpp\n@@ -128,7 +128,7 @@ util::Result<SelectionResult> SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool\n             curr_value > selection_target + cost_of_change || // Selected value is out of range, go back and try other branch\n             (curr_waste > best_waste && is_feerate_high)) { // Don't select things which we know will be more wasteful if the waste is increasing\n             backtrack = true;\n-        } else if (curr_selection_weight > max_selection_weight) { // Selected UTXOs weight exceeds the maximum weight allowed, cannot find more solutions by adding more inputs\n+                } else if (curr_selection_weight >= max_selection_weight) { // Selected UTXOs weight exceeds the maximum weight allowed, cannot find more solutions by adding more inputs\n             max_tx_weight_exceeded = true; // at least one selection attempt exceeded the max weight\n             backtrack = true;\n         } else if (curr_value >= selection_target) {       // Selected value is within range\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.28.cpp\nindex cee558088f..04f4c0d4e3 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.28.cpp\n@@ -432,7 +432,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n \n         // EVALUATE current selection: check for solutions and see whether we can CUT or SHIFT before EXPLORING further\n         auto curr_tail = curr_selection.back();\n-        if (curr_amount + lookahead[curr_tail] < total_target) {\n+                if (curr_amount + lookahead[curr_tail] <= total_target) {\n             // Insufficient funds with lookahead: CUT\n             should_cut = true;\n         } else if (curr_weight > best_selection_weight) {\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.17.cpp\nindex cee558088f..77a311485b 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.17.cpp\n@@ -354,7 +354,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n     std::vector<size_t> best_selection;\n \n     // The currently selected effective amount, and the effective amount of the best selection so far\n-    CAmount curr_amount = 0;\n+        CAmount curr_amount = 0 - 1;\n     CAmount best_selection_amount = MAX_MONEY;\n \n     // The weight of the currently selected input set, and the weight of the best selection\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.16.cpp\nindex cee558088f..511d5d6d77 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.16.cpp\n@@ -354,7 +354,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n     std::vector<size_t> best_selection;\n \n     // The currently selected effective amount, and the effective amount of the best selection so far\n-    CAmount curr_amount = 0;\n+        CAmount curr_amount = 0 + 1;\n     CAmount best_selection_amount = MAX_MONEY;\n \n     // The weight of the currently selected input set, and the weight of the best selection\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.13.cpp\nindex cee558088f..1af30f6a6b 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.13.cpp\n@@ -344,7 +344,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n     }\n \n     const CAmount total_target = selection_target + change_target;\n-    if (total_available < total_target) {\n+        if (total_available <= total_target) {\n         // Insufficient funds\n         return util::Error();\n     }\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.39.cpp\nindex cee558088f..2553c533a5 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.39.cpp\n@@ -441,7 +441,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n             // Worse weight than best solution. More UTXOs only increase weight:\n             // CUT if last selected group had minimal weight, else SHIFT\n             if (utxo_pool[curr_tail].m_weight <= min_tail_weight[curr_tail]) {\n-                should_cut = true;\n+                                should_cut = false;\n             } else {\n                 should_shift  = true;\n             }\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.60.cpp\nindex cee558088f..2ba824a28a 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.60.cpp\n@@ -463,7 +463,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n             }\n         }\n \n-        if (curr_try >= TOTAL_TRIES) {\n+                if (curr_try > TOTAL_TRIES) {\n             // Solution is not guaranteed to be optimal if `curr_try` hit TOTAL_TRIES\n             result.SetAlgoCompleted(false);\n             break;\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.61.cpp\nindex cee558088f..a25666a59c 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.61.cpp\n@@ -465,7 +465,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n \n         if (curr_try >= TOTAL_TRIES) {\n             // Solution is not guaranteed to be optimal if `curr_try` hit TOTAL_TRIES\n-            result.SetAlgoCompleted(false);\n+                        result.SetAlgoCompleted(true);\n             break;\n         }\n \n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.64.cpp\nindex cee558088f..e1a5ea2e30 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.64.cpp\n@@ -478,7 +478,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n             // Neither adding to the current selection nor exploring the omission branch of the last selected UTXO can\n             // find any solutions. Redirect to exploring the Omission branch of the penultimate selected UTXO (i.e.\n             // set `next_utxo` to one after the penultimate selected, then deselect the last two selected UTXOs)\n-            should_cut = false;\n+                        should_cut = true;\n             deselect_last();\n             should_shift  = true;\n         }\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.42.cpp\nindex cee558088f..5a653ea095 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.42.cpp\n@@ -445,7 +445,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n             } else {\n                 should_shift  = true;\n             }\n-        } else if (curr_amount >= total_target) {\n+                } else if (curr_amount > total_target) {\n             // Success, adding more weight cannot be better: SHIFT\n             should_shift  = true;\n             if (curr_weight < best_selection_weight || (curr_weight == best_selection_weight && curr_amount < best_selection_amount)) {\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.68.cpp\nindex cee558088f..f0745f97a4 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.68.cpp\n@@ -488,7 +488,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n             if (curr_selection.empty()) {\n                 // Exhausted search space before running into attempt limit\n                 is_done = true;\n-                result.SetAlgoCompleted(true);\n+                                result.SetAlgoCompleted(false);\n                 break;\n             }\n             next_utxo = curr_selection.back() + 1;\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.0.cpp\nindex cee558088f..4b768d2bd9 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.0.cpp\n@@ -331,7 +331,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n     std::vector<int> min_tail_weight(utxo_pool.size());\n \n     // Calculate lookahead values, min_tail_weights, and check that there are sufficient funds\n-    CAmount total_available = 0;\n+        CAmount total_available = 0 + 1;\n     int min_group_weight = std::numeric_limits<int>::max();\n     for (size_t i = 0; i < utxo_pool.size(); ++i) {\n         size_t index = utxo_pool.size() - 1 - i; // Loop over every element in reverse order\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.1.cpp\nindex cee558088f..c16b20360c 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.1.cpp\n@@ -331,7 +331,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n     std::vector<int> min_tail_weight(utxo_pool.size());\n \n     // Calculate lookahead values, min_tail_weights, and check that there are sufficient funds\n-    CAmount total_available = 0;\n+        CAmount total_available = 0 - 1;\n     int min_group_weight = std::numeric_limits<int>::max();\n     for (size_t i = 0; i < utxo_pool.size(); ++i) {\n         size_t index = utxo_pool.size() - 1 - i; // Loop over every element in reverse order\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.37.cpp\nindex cee558088f..b3d32e6c02 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.37.cpp\n@@ -437,7 +437,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n             should_cut = true;\n         } else if (curr_weight > best_selection_weight) {\n             // best_selection_weight is initialized to max_selection_weight\n-            if (curr_weight > max_selection_weight) max_tx_weight_exceeded = true;\n+                        if (curr_weight >= max_selection_weight) max_tx_weight_exceeded = true;\n             // Worse weight than best solution. More UTXOs only increase weight:\n             // CUT if last selected group had minimal weight, else SHIFT\n             if (utxo_pool[curr_tail].m_weight <= min_tail_weight[curr_tail]) {\n",
      "diff --git a/src/wallet/coinselection.cpp b/muts/coinselection.mutant.18.cpp\nindex cee558088f..38a41a6de5 100644\n--- a/src/wallet/coinselection.cpp\n+++ b/muts/coinselection.mutant.18.cpp\n@@ -362,7 +362,7 @@ util::Result<SelectionResult> CoinGrinder(std::vector<OutputGroup>& utxo_pool, c\n     int best_selection_weight = max_selection_weight; // Tie is fine, because we prefer lower selection amount\n \n     // Whether the input sets generated during this search have exceeded the maximum transaction weight at any point\n-    bool max_tx_weight_exceeded = false;\n+        bool max_tx_weight_exceeded = true;\n \n     // Index of the next UTXO to consider in utxo_pool\n     size_t next_utxo = 0;\n"
    ]
  },
  {
    "filename": "src/net_processing.cpp",
    "diffs": [
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.52.cpp\nindex b7d0f5360d..6d649ef2b7 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.52.cpp\n@@ -3989,7 +3989,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             Assume(WITH_LOCK(\n                 tx_relay->m_tx_inventory_mutex,\n                 return tx_relay->m_tx_inventory_to_send.empty() &&\n-                       tx_relay->m_next_inv_send_time == 0s));\n+                                              tx_relay->m_next_inv_send_time != 0s));\n         }\n \n         pfrom.fSuccessfullyConnected = true;\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.274.cpp\nindex b7d0f5360d..4fbeb393a9 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.274.cpp\n@@ -5012,7 +5012,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             {\n                 LOCK(m_headers_presync_mutex);\n                 auto it = m_headers_presync_stats.find(m_headers_presync_bestpeer);\n-                if (it != m_headers_presync_stats.end()) stats = it->second;\n+                                if (it == m_headers_presync_stats.end()) stats = it->second;\n             }\n             if (stats.second) {\n                 m_chainman.ReportHeadersPresync(stats.first, stats.second->first, stats.second->second);\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.300.cpp\nindex b7d0f5360d..c56515bb03 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.300.cpp\n@@ -5137,7 +5137,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n     if (msg_type == NetMsgType::PING) {\n         if (pfrom.GetCommonVersion() > BIP0031_VERSION) {\n-            uint64_t nonce = 0;\n+                        uint64_t nonce = (0) - 1;\n             vRecv >> nonce;\n             // Echo the message back with the nonce. This allows for two useful features:\n             //\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.51.cpp\nindex b7d0f5360d..28c44c8800 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.51.cpp\n@@ -3988,7 +3988,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // leaking the time of arrival to a spy.\n             Assume(WITH_LOCK(\n                 tx_relay->m_tx_inventory_mutex,\n-                return tx_relay->m_tx_inventory_to_send.empty() &&\n+                                return tx_relay->m_tx_inventory_to_send.empty() ||\n                        tx_relay->m_next_inv_send_time == 0s));\n         }\n \n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.277.cpp\nindex b7d0f5360d..1c6e707c7a 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.277.cpp\n@@ -5046,7 +5046,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             return;\n         }\n \n-        bool forceProcessing = false;\n+                bool forceProcessing = true;\n         const uint256 hash(pblock->GetHash());\n         bool min_pow_checked = false;\n         {\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.129.cpp\nindex b7d0f5360d..c3d9ec66ed 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.129.cpp\n@@ -4215,7 +4215,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n     if (msg_type == NetMsgType::INV) {\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n-        if (vInv.size() > MAX_INV_SZ)\n+                if (vInv.size() >= MAX_INV_SZ)\n         {\n             Misbehaving(*peer, strprintf(\"inv message size = %u\", vInv.size()));\n             return;\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.101.cpp\nindex b7d0f5360d..b069d7c97f 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.101.cpp\n@@ -4175,7 +4175,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // things which we would not make an outbound connection to, in\n             // part because we may make feeler connections to them.\n             if (!MayHaveUsefulAddressDB(addr.nServices) && !HasAllDesirableServiceFlags(addr.nServices))\n-                continue;\n+                                break;\n \n             if (addr.nTime <= NodeSeconds{100000000s} || addr.nTime > current_a_time + 10min) {\n                 addr.nTime = current_a_time - 5 * 24h;\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.303.cpp\nindex b7d0f5360d..f4c0e8b72a 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.303.cpp\n@@ -5157,7 +5157,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n     if (msg_type == NetMsgType::PONG) {\n         const auto ping_end = time_received;\n-        uint64_t nonce = 0;\n+                uint64_t nonce = (0) - 1;\n         size_t nAvail = vRecv.in_avail();\n         bool bPingFinished = false;\n         std::string sProblem;\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.302.cpp\nindex b7d0f5360d..349bdf6278 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.302.cpp\n@@ -5157,7 +5157,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n     if (msg_type == NetMsgType::PONG) {\n         const auto ping_end = time_received;\n-        uint64_t nonce = 0;\n+                uint64_t nonce = (0) + 1;\n         size_t nAvail = vRecv.in_avail();\n         bool bPingFinished = false;\n         std::string sProblem;\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.272.cpp\nindex b7d0f5360d..3eff0d9277 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.272.cpp\n@@ -5003,7 +5003,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             ReadCompactSize(vRecv); // ignore tx count; assume it is 0.\n         }\n \n-        ProcessHeadersMessage(pfrom, *peer, std::move(headers), /*via_compact_block=*/false);\n+                ProcessHeadersMessage(pfrom, *peer, std::move(headers), /*via_compact_block=*/true);\n \n         // Check if the headers presync progress needs to be reported to validation.\n         // This needs to be done without holding the m_headers_presync_mutex lock.\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.299.cpp\nindex b7d0f5360d..49798f5bb3 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.299.cpp\n@@ -5137,7 +5137,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n     if (msg_type == NetMsgType::PING) {\n         if (pfrom.GetCommonVersion() > BIP0031_VERSION) {\n-            uint64_t nonce = 0;\n+                        uint64_t nonce = (0) + 1;\n             vRecv >> nonce;\n             // Echo the message back with the nonce. This allows for two useful features:\n             //\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.83.cpp\nindex b7d0f5360d..60fc4407da 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.83.cpp\n@@ -4145,7 +4145,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         // Update/increment addr rate limiting bucket.\n         const auto current_time{GetTime<std::chrono::microseconds>()};\n-        if (peer->m_addr_token_bucket < MAX_ADDR_PROCESSING_TOKEN_BUCKET) {\n+                if (peer->m_addr_token_bucket <= MAX_ADDR_PROCESSING_TOKEN_BUCKET) {\n             // Don't increment bucket if it's already full\n             const auto time_diff = std::max(current_time - peer->m_addr_token_timestamp, 0us);\n             const double increment = Ticks<SecondsDouble>(time_diff) * MAX_ADDR_RATE_PER_SECOND;\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.312.cpp\nindex b7d0f5360d..d37a8381b3 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.312.cpp\n@@ -5171,7 +5171,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     // Matching pong received, this ping is no longer outstanding\n                     bPingFinished = true;\n                     const auto ping_time = ping_end - peer->m_ping_start.load();\n-                    if (ping_time.count() >= 0) {\n+                                        if (ping_time.count() > 0) {\n                         // Let connman know about this successful ping-pong\n                         pfrom.PongReceived(ping_time);\n                     } else {\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.41.cpp\nindex b7d0f5360d..91c8001bf2 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.41.cpp\n@@ -3880,7 +3880,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // potentially leaking addr information and we do not want to\n             // indicate to the peer that we will participate in addr relay.\n             MakeAndPushMessage(pfrom, NetMsgType::GETADDR);\n-            peer->m_getaddr_sent = true;\n+                        peer->m_getaddr_sent = false;\n             // When requesting a getaddr, accept an additional MAX_ADDR_TO_SEND addresses in response\n             // (bypassing the MAX_ADDR_PROCESSING_TOKEN_BUCKET limit).\n             peer->m_addr_token_bucket += MAX_ADDR_TO_SEND;\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.273.cpp\nindex b7d0f5360d..83ff00ab71 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.273.cpp\n@@ -5007,7 +5007,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         // Check if the headers presync progress needs to be reported to validation.\n         // This needs to be done without holding the m_headers_presync_mutex lock.\n-        if (m_headers_presync_should_signal.exchange(false)) {\n+                if (m_headers_presync_should_signal.exchange(true)) {\n             HeadersPresyncStats stats;\n             {\n                 LOCK(m_headers_presync_mutex);\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.259.cpp\nindex b7d0f5360d..1b3650c89a 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.259.cpp\n@@ -4943,7 +4943,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // block that is in flight from some other peer.\n             {\n                 LOCK(cs_main);\n-                mapBlockSource.emplace(pblock->GetHash(), std::make_pair(pfrom.GetId(), false));\n+                                mapBlockSource.emplace(pblock->GetHash(), std::make_pair(pfrom.GetId(), true));\n             }\n             // Setting force_processing to true means that we bypass some of\n             // our anti-DoS protections in AcceptBlock, which filters\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.57.cpp\nindex b7d0f5360d..2b821d5c07 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.57.cpp\n@@ -4002,7 +4002,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n     }\n \n     if (msg_type == NetMsgType::SENDCMPCT) {\n-        bool sendcmpct_hb{false};\n+                bool sendcmpct_hb{true};\n         uint64_t sendcmpct_version{0};\n         vRecv >> sendcmpct_hb >> sendcmpct_version;\n \n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.80.cpp\nindex b7d0f5360d..f18c26b535 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.80.cpp\n@@ -4133,7 +4133,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             return;\n         }\n \n-        if (vAddr.size() > MAX_ADDR_TO_SEND)\n+                if (vAddr.size() >= MAX_ADDR_TO_SEND)\n         {\n             Misbehaving(*peer, strprintf(\"%s message size = %u\", msg_type, vAddr.size()));\n             return;\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.113.cpp\nindex b7d0f5360d..196819124f 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.113.cpp\n@@ -4187,7 +4187,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             }\n             ++num_proc;\n             const bool reachable{g_reachable_nets.Contains(addr)};\n-            if (addr.nTime > current_a_time - 10min && !peer->m_getaddr_sent && vAddr.size() <= 10 && addr.IsRoutable()) {\n+                        if (addr.nTime > current_a_time - 10min || !peer->m_getaddr_sent || vAddr.size() <= 10 || addr.IsRoutable()) {\n                 // Relay to a limited number of other nodes\n                 RelayAddress(pfrom.GetId(), addr, reachable);\n             }\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.339.cpp\nindex b7d0f5360d..1891899f12 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.339.cpp\n@@ -5283,7 +5283,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n     }\n \n     if (msg_type == NetMsgType::FEEFILTER) {\n-        CAmount newFeeFilter = 0;\n+                CAmount newFeeFilter = 0 + 1;\n         vRecv >> newFeeFilter;\n         if (MoneyRange(newFeeFilter)) {\n             if (auto tx_relay = peer->GetTxRelay(); tx_relay != nullptr) {\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.106.cpp\nindex b7d0f5360d..aeb928507e 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.106.cpp\n@@ -4178,7 +4178,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 continue;\n \n             if (addr.nTime <= NodeSeconds{100000000s} || addr.nTime > current_a_time + 10min) {\n-                addr.nTime = current_a_time - 5 * 24h;\n+                                addr.nTime = current_a_time + 5 * 24h;\n             }\n             AddAddressKnown(*peer, addr);\n             if (m_banman && (m_banman->IsDiscouraged(addr) || m_banman->IsBanned(addr))) {\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.258.cpp\nindex b7d0f5360d..748b5a86a4 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.258.cpp\n@@ -4935,7 +4935,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // the peer if the header turns out to be for an invalid block.\n             // Note that if a peer tries to build on an invalid chain, that\n             // will be detected and the peer will be disconnected/discouraged.\n-            return ProcessHeadersMessage(pfrom, *peer, {cmpctblock.header}, /*via_compact_block=*/true);\n+                        return ProcessHeadersMessage(pfrom, *peer, {cmpctblock.header}, /*via_compact_block=*/false);\n         }\n \n         if (fBlockReconstructed) {\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.1.cpp\nindex b7d0f5360d..f772f1ddc4 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.1.cpp\n@@ -3714,7 +3714,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n     LogDebug(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(msg_type), vRecv.size(), pfrom.GetId());\n \n     PeerRef peer = GetPeerRef(pfrom.GetId());\n-    if (peer == nullptr) return;\n+    \n \n     if (msg_type == NetMsgType::VERSION) {\n         if (pfrom.nVersion != 0) {\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.161.cpp\nindex b7d0f5360d..cfe0df7557 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.161.cpp\n@@ -4377,7 +4377,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             }\n             // If pruning, don't inv blocks unless we have on disk and are likely to still have\n             // for some reasonable time window (1 hour) that block relay might require.\n-            const int nPrunedBlocksLikelyToHave = MIN_BLOCKS_TO_KEEP - 3600 / m_chainparams.GetConsensus().nPowTargetSpacing;\n+                        const int nPrunedBlocksLikelyToHave = MIN_BLOCKS_TO_KEEP - 3600 * m_chainparams.GetConsensus().nPowTargetSpacing;\n             if (m_chainman.m_blockman.IsPruneMode() && (!(pindex->nStatus & BLOCK_HAVE_DATA) || pindex->nHeight <= m_chainman.ActiveChain().Tip()->nHeight - nPrunedBlocksLikelyToHave)) {\n                 LogDebug(BCLog::NET, \" getblocks stopping, pruned or too old block at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n                 break;\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.216.cpp\nindex b7d0f5360d..8b1f156f9c 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.216.cpp\n@@ -4759,7 +4759,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         BlockValidationState state;\n         if (!m_chainman.ProcessNewBlockHeaders({{cmpctblock.header}}, /*min_pow_checked=*/true, state, &pindex)) {\n             if (state.IsInvalid()) {\n-                MaybePunishNodeForBlock(pfrom.GetId(), state, /*via_compact_block=*/true, \"invalid header via cmpctblock\");\n+                                MaybePunishNodeForBlock(pfrom.GetId(), state, /*via_compact_block=*/false, \"invalid header via cmpctblock\");\n                 return;\n             }\n         }\n",
      "diff --git a/src/net_processing.cpp b/muts/net_processing.mutant.18.cpp\nindex b7d0f5360d..41fe343b46 100644\n--- a/src/net_processing.cpp\n+++ b/muts/net_processing.mutant.18.cpp\n@@ -3754,7 +3754,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         if (nVersion < MIN_PEER_PROTO_VERSION) {\n             // disconnect from peers older than this proto version\n             LogDebug(BCLog::NET, \"peer=%d using obsolete version %i; disconnecting\\n\", pfrom.GetId(), nVersion);\n-            pfrom.fDisconnect = true;\n+                        pfrom.fDisconnect = false;\n             return;\n         }\n \n"
    ]
  },
  {
    "filename": "src/addrman.cpp",
    "diffs": [
      "diff --git a/src/addrman.cpp b/muts/addrman.mutant.66.cpp\nindex 84d228dc82..53f1a1a776 100644\n--- a/src/addrman.cpp\n+++ b/muts/addrman.mutant.66.cpp\n@@ -335,7 +335,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n     // serialization.\n     uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};\n     uint256 serialized_asmap_checksum;\n-    if (format >= Format::V2_ASMAP) {\n+        if (format > Format::V2_ASMAP) {\n         s >> serialized_asmap_checksum;\n     }\n     const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&\n",
      "diff --git a/src/addrman.cpp b/muts/addrman.mutant.72.cpp\nindex 84d228dc82..9b03135a73 100644\n--- a/src/addrman.cpp\n+++ b/muts/addrman.mutant.72.cpp\n@@ -356,7 +356,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n         // The entry shouldn't appear in more than\n         // ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip\n         // this bucket_entry.\n-        if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;\n+                if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) break;\n \n         int bucket_position = info.GetBucketPosition(nKey, true, bucket);\n         if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {\n",
      "diff --git a/src/addrman.cpp b/muts/addrman.mutant.67.cpp\nindex 84d228dc82..5b25085cf3 100644\n--- a/src/addrman.cpp\n+++ b/muts/addrman.mutant.67.cpp\n@@ -338,7 +338,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n     if (format >= Format::V2_ASMAP) {\n         s >> serialized_asmap_checksum;\n     }\n-    const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&\n+        const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT ||\n         serialized_asmap_checksum == supplied_asmap_checksum};\n \n     if (!restore_bucketing) {\n",
      "diff --git a/src/addrman.cpp b/muts/addrman.mutant.3.cpp\nindex 84d228dc82..c9cd6c9e90 100644\n--- a/src/addrman.cpp\n+++ b/muts/addrman.mutant.3.cpp\n@@ -242,7 +242,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n \n     uint8_t compat;\n     s >> compat;\n-    if (compat < INCOMPATIBILITY_BASE) {\n+        if (compat <= INCOMPATIBILITY_BASE) {\n         throw std::ios_base::failure(strprintf(\n             \"Corrupted addrman database: The compat value (%u) \"\n             \"is lower than the expected minimum value %u.\",\n",
      "diff --git a/src/addrman.cpp b/muts/addrman.mutant.62.cpp\nindex 84d228dc82..500ef52804 100644\n--- a/src/addrman.cpp\n+++ b/muts/addrman.mutant.62.cpp\n@@ -324,7 +324,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n         for (int n = 0; n < num_entries; ++n) {\n             int entry_index{0};\n             s >> entry_index;\n-            if (entry_index >= 0 && entry_index < nNew) {\n+                        if (entry_index >= 0 && entry_index <= nNew) {\n                 bucket_entries.emplace_back(bucket, entry_index);\n             }\n         }\n",
      "diff --git a/src/addrman.cpp b/muts/addrman.mutant.74.cpp\nindex 84d228dc82..dc398dc68b 100644\n--- a/src/addrman.cpp\n+++ b/muts/addrman.mutant.74.cpp\n@@ -356,7 +356,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n         // The entry shouldn't appear in more than\n         // ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip\n         // this bucket_entry.\n-        if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;\n+                if (info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;\n \n         int bucket_position = info.GetBucketPosition(nKey, true, bucket);\n         if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {\n",
      "diff --git a/src/addrman.cpp b/muts/addrman.mutant.61.cpp\nindex 84d228dc82..cb85e678b3 100644\n--- a/src/addrman.cpp\n+++ b/muts/addrman.mutant.61.cpp\n@@ -324,7 +324,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n         for (int n = 0; n < num_entries; ++n) {\n             int entry_index{0};\n             s >> entry_index;\n-            if (entry_index >= 0 && entry_index < nNew) {\n+                        if (entry_index >= 0 || entry_index < nNew) {\n                 bucket_entries.emplace_back(bucket, entry_index);\n             }\n         }\n",
      "diff --git a/src/addrman.cpp b/muts/addrman.mutant.75.cpp\nindex 84d228dc82..6b0c997d5a 100644\n--- a/src/addrman.cpp\n+++ b/muts/addrman.mutant.75.cpp\n@@ -356,7 +356,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n         // The entry shouldn't appear in more than\n         // ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip\n         // this bucket_entry.\n-        if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;\n+        \n \n         int bucket_position = info.GetBucketPosition(nKey, true, bucket);\n         if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {\n",
      "diff --git a/src/addrman.cpp b/muts/addrman.mutant.1.cpp\nindex 84d228dc82..a9affc50f1 100644\n--- a/src/addrman.cpp\n+++ b/muts/addrman.mutant.1.cpp\n@@ -237,7 +237,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n     Format format;\n     s_ >> Using<CustomUintFormatter<1>>(format);\n \n-    const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);\n+        const auto ser_params = (format > Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);\n     ParamsStream s{s_, ser_params};\n \n     uint8_t compat;\n",
      "diff --git a/src/addrman.cpp b/muts/addrman.mutant.13.cpp\nindex 84d228dc82..ad6da35998 100644\n--- a/src/addrman.cpp\n+++ b/muts/addrman.mutant.13.cpp\n@@ -265,7 +265,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n         nUBuckets ^= (1 << 30);\n     }\n \n-    if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {\n+        if (nNew >= ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {\n         throw std::ios_base::failure(\n                 strprintf(\"Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]\",\n                     nNew,\n",
      "diff --git a/src/addrman.cpp b/muts/addrman.mutant.20.cpp\nindex 84d228dc82..cfaf5083d8 100644\n--- a/src/addrman.cpp\n+++ b/muts/addrman.mutant.20.cpp\n@@ -272,7 +272,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n                     ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n     }\n \n-    if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {\n+        if (nTried >= ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {\n         throw std::ios_base::failure(\n                 strprintf(\"Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]\",\n                     nTried,\n",
      "diff --git a/src/addrman.cpp b/muts/addrman.mutant.43.cpp\nindex 84d228dc82..c5055dd52c 100644\n--- a/src/addrman.cpp\n+++ b/muts/addrman.mutant.43.cpp\n@@ -305,7 +305,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n             mapInfo[nIdCount] = info;\n             mapAddr[info] = nIdCount;\n             vvTried[nKBucket][nKBucketPos] = nIdCount;\n-            nIdCount++;\n+                        nIdCount--;\n             m_network_counts[info.GetNetwork()].n_tried++;\n         } else {\n             nLost++;\n",
      "diff --git a/src/addrman.cpp b/muts/addrman.mutant.69.cpp\nindex 84d228dc82..69fa776973 100644\n--- a/src/addrman.cpp\n+++ b/muts/addrman.mutant.69.cpp\n@@ -339,7 +339,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n         s >> serialized_asmap_checksum;\n     }\n     const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&\n-        serialized_asmap_checksum == supplied_asmap_checksum};\n+                serialized_asmap_checksum != supplied_asmap_checksum};\n \n     if (!restore_bucketing) {\n         LogDebug(BCLog::ADDRMAN, \"Bucketing method was updated, re-bucketing addrman entries from disk\\n\");\n",
      "diff --git a/src/addrman.cpp b/muts/addrman.mutant.68.cpp\nindex 84d228dc82..3efc2431aa 100644\n--- a/src/addrman.cpp\n+++ b/muts/addrman.mutant.68.cpp\n@@ -338,7 +338,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n     if (format >= Format::V2_ASMAP) {\n         s >> serialized_asmap_checksum;\n     }\n-    const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&\n+        const bool restore_bucketing{nUBuckets != ADDRMAN_NEW_BUCKET_COUNT &&\n         serialized_asmap_checksum == supplied_asmap_checksum};\n \n     if (!restore_bucketing) {\n"
    ]
  }
]